import pandas as pd
from pathlib import Path
from datetime import datetime, date, timedelta
from openpyxl import load_workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.formatting.rule import DataBarRule, ColorScaleRule, Rule
from openpyxl.styles.differential import DifferentialStyle
from openpyxl.utils import get_column_letter
import logging

# =========================
# LOGGING
# =========================
logging.basicConfig(
    level=logging.INFO, 
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# =========================
# CONFIGURACI√ìN
# =========================
BASE_PATH = Path("c:/Copia-reporte-Aclarabot/Reporte_Excel")
MES_ANIO = datetime.now().strftime("%b-%Y")

ARCHIVO_ENTRADA = BASE_PATH / MES_ANIO / f"{MES_ANIO}.xlsx"
ARCHIVO_SALIDA = BASE_PATH / MES_ANIO / f"ReporteDEV_Aclarapp_{MES_ANIO}.xlsx"

HOJA_ORIGEN = "Reporte_Completo"
HOJA_REPORTE = "Reporte Aclarapp"
HOJA_USUARIO_NO_ENCONTRADO = "Usuario no Encontrado"
HOJA_DUPLICADOS = "AclaracionID duplicadas"
HOJA_RESUMEN = "Resumen por Agente"

# =========================
# ORDEN FINAL
# =========================
COLUMNAS_FINALES = [
    "ENTORNO", "Fecha", "Tipo de tarjeta", "Tipo de aclaracion", "Detalles de aclaracion",
    "Numero de registro", "NOMBRE", "Supervisor", "Site", "Skill", "Folio", "CIS", "Cargos",
    "AclaracionID", "Fecha Creaci√≥n", "Fecha Enviado", "Fecha Asignacion", "Fecha Atendido",
    "Captura de Cargos", "Tiempo Robot", "Aclaraci√≥n",
    "Captura de Cargos segundos", "Tiempo Robot segundos",
    "Captura de Cargos categoria", "Tiempo Robot Categoria"
]

# =========================
# FUNCIONES
# =========================
def convertir_fecha_universal(col):
    """
    Convierte una columna a formato datetime usando m√∫ltiples formatos.
    """
    formatos = [
        "%d/%m/%Y %H:%M", "%d/%m/%Y %H:%M:%S",
        "%d/%m/%Y %I:%M:%S %p", "%d/%m/%Y %I:%M %p",
        "%Y-%m-%d %H:%M:%S", "%d/%m/%Y"
    ]
    
    def parse_date(value):
        if pd.isna(value):
            return pd.NaT
        if isinstance(value, (datetime, pd.Timestamp)):
            return value
        
        str_value = str(value).strip()
        for fmt in formatos:
            try:
                return datetime.strptime(str_value, fmt)
            except (ValueError, TypeError):
                continue
        
        try:
            return pd.to_datetime(str_value, dayfirst=True, errors="coerce")
        except:
            return pd.NaT
    
    return col.apply(parse_date)

def categorizar_tiempo(segundos):
    """
    Categoriza el tiempo en segundos a rangos espec√≠ficos.
    """
    if pd.isna(segundos):
        return "Sin dato"
    if segundos > 300:
        return "M√°s de 5 minutos"
    if segundos > 180:
        return "3 a 5 minutos"
    if segundos > 90:
        return "1.5 a 3 minutos"
    return "Menor a 1.5 minutos"

def aplicar_estilos(workbook, worksheet_name):
    """
    Aplica estilos consistentes a una hoja de Excel.
    """
    ws = workbook[worksheet_name]
    
    # Estilos para encabezado
    header_fill = PatternFill("solid", fgColor="C00000")
    header_font = Font(color="FFFFFF", bold=True)
    center_alignment = Alignment(horizontal="center", vertical="center")
    
    # Aplicar a encabezados (fila 1)
    for cell in ws[1]:
        cell.fill = header_fill
        cell.font = header_font
        cell.alignment = center_alignment
    
    # Aplicar alineaci√≥n central a todas las celdas de datos
    for row in ws.iter_rows(min_row=2):
        for cell in row:
            cell.alignment = center_alignment
    
    # Ajustar ancho de columnas autom√°ticamente
    for column in ws.columns:
        max_length = 0
        column_letter = get_column_letter(column[0].column)
        
        for cell in column:
            try:
                cell_length = len(str(cell.value)) if cell.value else 0
                if cell_length > max_length:
                    max_length = cell_length
            except:
                pass
        
        adjusted_width = min(max_length + 2, 50)  # M√°ximo 50 caracteres
        ws.column_dimensions[column_letter].width = adjusted_width
    
    # Aplicar formato espec√≠fico para "Reporte Aclarapp"
    if worksheet_name == HOJA_REPORTE:
        aplicar_formato_tiempos(workbook, ws)

def aplicar_formato_tiempos(workbook, worksheet):
    """
    Aplica formato condicional de colores y formato mm:ss a las columnas de tiempo.
    """
    # Encontrar √≠ndices de las columnas de tiempo
    col_indices = {}
    for idx, cell in enumerate(worksheet[1], 1):
        if cell.value in ["Captura de Cargos", "Tiempo Robot"]:
            col_indices[cell.value] = idx
    
    for col_name, col_idx in col_indices.items():
        col_letter = get_column_letter(col_idx)
        
        # Aplicar formato mm:ss a toda la columna
        for row in range(2, worksheet.max_row + 1):
            cell = worksheet.cell(row=row, column=col_idx)
            if cell.value:
                # Si es un timedelta, mostrar como mm:ss
                if isinstance(cell.value, (timedelta, pd.Timedelta)):
                    total_seconds = int(cell.value.total_seconds())
                    minutes = total_seconds // 60
                    seconds = total_seconds % 60
                    cell.value = f"{minutes:02d}:{seconds:02d}"
                # Establecer formato personalizado en Excel
                cell.number_format = "mm:ss"
        
        # Aplicar escala de colores a la columna de segundos correspondiente
        if col_name == "Captura de Cargos":
            seg_col_name = "Captura de Cargos segundos"
        else:
            seg_col_name = "Tiempo Robot segundos"
        
        # Buscar la columna de segundos correspondiente
        seg_col_idx = None
        for idx, cell in enumerate(worksheet[1], 1):
            if cell.value == seg_col_name:
                seg_col_idx = idx
                break
        
        if seg_col_idx:
            seg_col_letter = get_column_letter(seg_col_idx)
            
            # Definir rango para la escala de colores (excluyendo encabezado)
            start_row = 2
            end_row = worksheet.max_row
            rango = f"{col_letter}{start_row}:{col_letter}{end_row}"
            rango_segundos = f"{seg_col_letter}{start_row}:{seg_col_letter}{end_row}"
            
            # Crear regla de escala de colores
            # Rojo (alto) -> Amarillo (medio) -> Verde (bajo)
            color_scale = ColorScaleRule(
                start_type='min',
                start_color='63BE7B',  # Verde
                mid_type='percentile',
                mid_value=50,
                mid_color='FFEB84',    # Amarillo
                end_type='max',
                end_color='F8696B'     # Rojo
            )
            
            # Aplicar la escala de colores basada en los segundos
            try:
                # Intentar aplicar la escala de colores directamente
                worksheet.conditional_formatting.add(rango, color_scale)
            except Exception as e:
                logger.warning(f"No se pudo aplicar escala de colores: {e}")

def crear_resumen_por_agente(workbook, dataframe):
    """
    Crea una hoja de resumen por agente con estad√≠sticas diarias.
    """
    if dataframe.empty:
        logger.warning("DataFrame vac√≠o, no se puede crear resumen")
        return
    
    # Crear copia para no modificar el original
    df = dataframe.copy()
    
    # Crear columna de fecha (sin hora)
    df["Fecha_dia"] = df["Fecha"].dt.date
    dias = sorted(df["Fecha_dia"].unique())
    dias_str = [d.strftime("%d-%b").lower() for d in dias]
    
    # Crear nueva hoja
    if HOJA_RESUMEN in workbook.sheetnames:
        workbook.remove(workbook[HOJA_RESUMEN])
    ws = workbook.create_sheet(HOJA_RESUMEN)
    
    # Quitar l√≠neas de cuadr√≠cula
    ws.sheet_view.showGridLines = False
    
    # Definir bordes blancos
    white_border = Border(
        left=Side(style='thin', color='FFFFFF'),
        right=Side(style='thin', color='FFFFFF'),
        top=Side(style='thin', color='FFFFFF'),
        bottom=Side(style='thin', color='FFFFFF')
    )
    
    # Colores y estilos
    negro = PatternFill("solid", fgColor="000000")
    rojo = PatternFill("solid", fgColor="C00000")
    blanco = Font(color="FFFFFF", bold=True)
    center_alignment = Alignment(horizontal="center", vertical="center")
    
    col_inicio = 7  # Columna donde empiezan los d√≠as
    total_col = col_inicio + len(dias_str)  # Columna "Total"
    
    # ===== ENCABEZADOS SUPERIORES =====
    # D√≠as individuales
    for i, dia in enumerate(dias_str):
        celda = ws.cell(row=1, column=col_inicio + i, value=dia)
        celda.fill = negro
        celda.font = blanco
        celda.alignment = center_alignment
        celda.border = white_border
    
    # Columna "Total"
    celda_total = ws.cell(row=1, column=total_col, value="Total")
    celda_total.fill = rojo
    celda_total.font = blanco
    celda_total.alignment = center_alignment
    celda_total.border = white_border
    
    # ===== TOTALES POR SITE - CON BARRAS DE DATOS INDEPENDIENTES POR D√çA =====
    sites = ["CDMX", "GDL"]
    for fila_idx, site in enumerate(sites, start=2):
        celda_site = ws.cell(row=fila_idx, column=6, value=site)
        celda_site.fill = rojo
        celda_site.font = blanco
        celda_site.alignment = center_alignment
        celda_site.border = white_border
        
        total_site = 0
        
        # Aplicar barras de datos INDIVIDUALES por cada d√≠a
        for i, dia in enumerate(dias):
            count = len(df[(df["Site"] == site) & (df["Fecha_dia"] == dia)])
            celda = ws.cell(row=fila_idx, column=col_inicio + i, value=count)
            celda.alignment = center_alignment
            celda.border = white_border
            total_site += count
            
            # Aplicar barra de datos SOLIDA para cada celda individual
            if count > 0:
                regla = DataBarRule(
                    start_type="num", 
                    start_value=0,
                    end_type="max", 
                    color="FFD966",
                    gradient=False,  # Relleno s√≥lido
                    showValue=True
                )
                rango_celda = f"{get_column_letter(col_inicio + i)}{fila_idx}"
                ws.conditional_formatting.add(rango_celda, regla)
        
        # Celda de total para el site
        celda_total_site = ws.cell(row=fila_idx, column=total_col, value=total_site)
        celda_total_site.alignment = center_alignment
        celda_total_site.border = white_border
        
        # Aplicar barra de datos SOLIDA para el total del site
        if total_site > 0:
            regla_total = DataBarRule(
                start_type="num", 
                start_value=0,
                end_type="max", 
                color="63BE7B",
                gradient=False,  # Relleno s√≥lido
                showValue=True
            )
            rango_total = f"{get_column_letter(total_col)}{fila_idx}"
            ws.conditional_formatting.add(rango_total, regla_total)
    
    # ===== TOTAL GENERAL - CON BARRAS DE DATOS INDEPENDIENTES POR D√çA =====
    celda_total_label = ws.cell(row=4, column=6, value="Total")
    celda_total_label.fill = rojo
    celda_total_label.font = blanco
    celda_total_label.alignment = center_alignment
    celda_total_label.border = white_border
    
    # Aplicar barras de datos INDIVIDUALES por cada d√≠a para el total general
    for i, dia in enumerate(dias):
        count = len(df[df["Fecha_dia"] == dia])
        celda = ws.cell(row=4, column=col_inicio + i, value=count)
        celda.alignment = center_alignment
        celda.border = white_border
        
        # Aplicar barra de datos SOLIDA para cada celda individual del total general
        if count > 0:
            regla = DataBarRule(
                start_type="num", 
                start_value=0,
                end_type="max", 
                color="5B9BD5",  # Azul para totales diarios generales
                gradient=False,  # Relleno s√≥lido
                showValue=True
            )
            rango_celda = f"{get_column_letter(col_inicio + i)}4"
            ws.conditional_formatting.add(rango_celda, regla)
    
    total_general = len(df)
    celda_total_general = ws.cell(row=4, column=total_col, value=total_general)
    celda_total_general.alignment = center_alignment
    celda_total_general.border = white_border
    
    # Aplicar barra de datos SOLIDA para el total general
    if total_general > 0:
        regla_total_general = DataBarRule(
            start_type="num", 
            start_value=0,
            end_type="max", 
            color="4472C4",  # Azul m√°s oscuro para total general
            gradient=False,  # Relleno s√≥lido
            showValue=True
        )
        rango_total_general = f"{get_column_letter(total_col)}4"
        ws.conditional_formatting.add(rango_total_general, regla_total_general)
    
    # ===== DETALLE POR AGENTE - CON BARRAS DE DATOS INDEPENDIENTES POR D√çA =====
    fila_base = 6
    
    # Encabezados de agentes
    headers_agentes = ["Numero de registro", "NOMBRE", "Supervisor", "Site", "Skill"]
    for i, header in enumerate(headers_agentes, start=1):
        celda = ws.cell(row=fila_base, column=i, value=header)
        celda.fill = rojo
        celda.font = blanco
        celda.alignment = center_alignment
        celda.border = white_border
    
    # Encabezados de d√≠as (para secci√≥n de agentes)
    for i, dia in enumerate(dias_str):
        celda = ws.cell(row=fila_base, column=col_inicio + i, value=dia)
        celda.fill = rojo
        celda.font = blanco
        celda.alignment = center_alignment
        celda.border = white_border
    
    # Encabezado "Total" para agentes
    celda = ws.cell(row=fila_base, column=total_col, value="Total")
    celda.fill = negro
    celda.font = blanco
    celda.alignment = center_alignment
    celda.border = white_border
    
    # Datos por agente
    fila_actual = fila_base + 1
    
    # Agrupar por agentes
    grouped = df.groupby(headers_agentes)
    
    # Primero, recolectar todos los valores para establecer m√°ximos por columna
    max_por_columna = {col: 0 for col in range(col_inicio, total_col + 1)}
    valores_agentes = []  # Almacenar todos los valores para calcular m√°ximos
    
    for (keys, group) in grouped:
        valores_fila = []
        
        for i, dia in enumerate(dias):
            count = len(group[group["Fecha_dia"] == dia])
            valores_fila.append(count)
            if count > max_por_columna[col_inicio + i]:
                max_por_columna[col_inicio + i] = count
        
        total_agente = sum(valores_fila)
        valores_fila.append(total_agente)
        valores_agentes.append(valores_fila)
        
        if total_agente > max_por_columna[total_col]:
            max_por_columna[total_col] = total_agente
    
    # Ahora escribir los datos y aplicar barras de datos INDIVIDUALES
    fila_actual = fila_base + 1
    
    for idx, ((keys, group), valores_fila) in enumerate(zip(grouped, valores_agentes)):
        # Escribir datos del agente
        for i, value in enumerate(keys):
            celda = ws.cell(row=fila_actual, column=i + 1, value=value)
            celda.alignment = center_alignment
            celda.border = white_border
        
        # Escribir valores por d√≠a y aplicar barras de datos INDIVIDUALES
        for i in range(len(dias)):
            count = valores_fila[i]
            celda = ws.cell(row=fila_actual, column=col_inicio + i, value=count)
            celda.alignment = center_alignment
            celda.border = white_border
            
            # Aplicar barra de datos SOLIDA para cada celda individual
            if count > 0:
                regla = DataBarRule(
                    start_type="num", 
                    start_value=0,
                    end_type="num", 
                    end_value=max_por_columna[col_inicio + i] if max_por_columna[col_inicio + i] > 0 else 1,
                    color="FFD966",
                    gradient=False,  # Relleno s√≥lido
                    showValue=True
                )
                rango_celda = f"{get_column_letter(col_inicio + i)}{fila_actual}"
                ws.conditional_formatting.add(rango_celda, regla)
        
        # Total del agente
        total_agente = valores_fila[-1]
        celda_total_agente = ws.cell(row=fila_actual, column=total_col, value=total_agente)
        celda_total_agente.alignment = center_alignment
        celda_total_agente.border = white_border
        
        # Aplicar barra de datos SOLIDA para el total del agente
        if total_agente > 0:
            regla_total = DataBarRule(
                start_type="num", 
                start_value=0,
                end_type="num", 
                end_value=max_por_columna[total_col] if max_por_columna[total_col] > 0 else 1,
                color="63BE7B",
                gradient=False,  # Relleno s√≥lido
                showValue=True
            )
            rango_total = f"{get_column_letter(total_col)}{fila_actual}"
            ws.conditional_formatting.add(rango_total, regla_total)
        
        fila_actual += 1
    
    # Ajustar ancho de columnas
    for col in range(1, total_col + 1):
        col_letter = get_column_letter(col)
        ws.column_dimensions[col_letter].width = 15
    
    # Aplicar bordes blancos a todas las celdas usadas
    for row in ws.iter_rows(min_row=1, max_row=fila_actual-1, min_col=1, max_col=total_col):
        for cell in row:
            if not cell.border or cell.border.left.style is None:
                cell.border = white_border

def verificar_archivos():
    """
    Verifica que los archivos necesarios existan.
    """
    if not ARCHIVO_ENTRADA.exists():
        raise FileNotFoundError(f"Archivo de entrada no encontrado: {ARCHIVO_ENTRADA}")
    
    # Crear directorio de salida si no existe
    ARCHIVO_SALIDA.parent.mkdir(parents=True, exist_ok=True)

# =========================
# PROCESO PRINCIPAL
# =========================
def generar_reporte_dev():
    """
    Funci√≥n principal para generar el reporte DEV de Aclarapp.
    """
    try:
        logger.info("üöÄ Iniciando generaci√≥n de Reporte Aclarapp")
        
        # Verificar archivos
        verificar_archivos()
        
        # Cargar datos
        logger.info(f"üìÇ Cargando datos desde: {ARCHIVO_ENTRADA}")
        df = pd.read_excel(ARCHIVO_ENTRADA, sheet_name=HOJA_ORIGEN)
        
        if df.empty:
            logger.warning("El archivo de entrada est√° vac√≠o")
            return
        
        # Convertir fechas
        logger.info("üïê Convirtiendo formatos de fecha")
        columnas_fecha = ["Fecha", "Fecha Creaci√≥n", "Fecha Enviado", "Fecha Asignacion", "Fecha Atendido"]
        
        for col in columnas_fecha:
            if col in df.columns:
                df[col] = convertir_fecha_universal(df[col])
            else:
                logger.warning(f"Columna {col} no encontrada en el archivo de entrada")
                df[col] = pd.NaT
        
        # Convertir columnas a string
        for col in ["Folio", "CIS"]:
            if col in df.columns:
                df[col] = df[col].astype(str)
        
        # Filtrar usuarios no encontrados
        logger.info("üë§ Filtrando usuarios no encontrados")
        mask_usuario_no = df["NOMBRE"].isna() | (df["NOMBRE"].astype(str).str.strip() == "")
        df_usuario_no = df[mask_usuario_no].copy()
        df = df[~mask_usuario_no].copy()
        
        # Ordenar por fecha
        df = df.sort_values("Fecha", ascending=True)
        
        # Manejar duplicados
        logger.info("üîç Identificando duplicados")
        mask_duplicados = df.duplicated("AclaracionID", keep="first")
        df_duplicados = df[mask_duplicados].copy()
        df = df[~mask_duplicados].copy()
        
        # Calcular tiempos
        logger.info("‚è±Ô∏è Calculando m√©tricas de tiempo")
        df["Captura de Cargos"] = df["Fecha Enviado"] - df["Fecha Creaci√≥n"]
        df["Tiempo Robot"] = df["Fecha Atendido"] - df["Fecha Asignacion"]
        
        # Convertir a segundos
        df["Captura de Cargos segundos"] = df["Captura de Cargos"].dt.total_seconds()
        df["Tiempo Robot segundos"] = df["Tiempo Robot"].dt.total_seconds()
        
        # Categorizar tiempos
        df["Captura de Cargos categoria"] = df["Captura de Cargos segundos"].apply(categorizar_tiempo)
        df["Tiempo Robot Categoria"] = df["Tiempo Robot segundos"].apply(categorizar_tiempo)
        df["Aclaraci√≥n"] = 1
        
        # Asegurar que todas las columnas finales existan
        for col in COLUMNAS_FINALES:
            if col not in df.columns:
                logger.warning(f"Columna {col} no encontrada, se agregar√° vac√≠a")
                df[col] = None
        
        # Reordenar columnas
        df = df[COLUMNAS_FINALES]
        
        # Guardar en Excel
        logger.info(f"üíæ Guardando reporte en: {ARCHIVO_SALIDA}")
        with pd.ExcelWriter(ARCHIVO_SALIDA, engine="openpyxl") as writer:
            df.to_excel(writer, sheet_name=HOJA_REPORTE, index=False)
            if not df_usuario_no.empty:
                df_usuario_no.to_excel(writer, sheet_name=HOJA_USUARIO_NO_ENCONTRADO, index=False)
            if not df_duplicados.empty:
                df_duplicados.to_excel(writer, sheet_name=HOJA_DUPLICADOS, index=False)
        
        # Aplicar estilos y crear resumen
        logger.info("üé® Aplicando estilos y creando resumen")
        wb = load_workbook(ARCHIVO_SALIDA)
        
        # Crear resumen si hay datos
        if not df.empty:
            crear_resumen_por_agente(wb, df)
        
        # Aplicar estilos a todas las hojas
        for sheet_name in wb.sheetnames:
            aplicar_estilos(wb, sheet_name)
        
        # Guardar cambios
        wb.save(ARCHIVO_SALIDA)
        
        logger.info(f"‚úÖ Reporte generado exitosamente: {ARCHIVO_SALIDA}")
        logger.info(f"   - Registros procesados: {len(df)}")
        logger.info(f"   - Usuarios no encontrados: {len(df_usuario_no)}")
        logger.info(f"   - Duplicados encontrados: {len(df_duplicados)}")
        
    except FileNotFoundError as e:
        logger.error(f"‚ùå Error de archivo: {e}")
        raise
    except Exception as e:
        logger.error(f"‚ùå Error inesperado: {e}", exc_info=True)
        raise

# =========================
# EJECUCI√ìN
# =========================
if __name__ == "__main__":
    generar_reporte_dev()
