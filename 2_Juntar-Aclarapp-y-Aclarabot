import pandas as pd
import logging
from pathlib import Path
import unicodedata
import re

# =========================
# LOGGING
# =========================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# =========================
# CONFIGURACI√ìN
# =========================
BASE_PATH = Path("c:/Copia-reporte-Aclarabot")

ACLARABOT_PATH = next(BASE_PATH.glob("*.csv"))  # ej: 06-Jan.csv
ACLARAPP_PATH = BASE_PATH / "Copy-Aclarapp" / "TablaCopiadaDeAclarapp.csv"
AGENTES_PATH = BASE_PATH / "Copy-Aclarapp" / "InfoAgentes.csv"

OUTPUT_FILE = BASE_PATH / "Acumulado_filtrado_11-Dec.csv"

# =========================
# FUNCIONES
# =========================
def normalizar_columna(col):
    col = col.strip()
    col = unicodedata.normalize("NFKD", col)
    col = col.encode("ascii", "ignore").decode("utf-8")
    return col

def cargar_csv(ruta, sep=","):
    df = pd.read_csv(
        ruta,
        sep=sep,
        dtype=str,
        encoding="utf-8-sig",
        on_bad_lines="warn"
    )
    df.columns = [normalizar_columna(c) for c in df.columns]
    df = df.apply(lambda col: col.str.strip() if col.dtype == "object" else col)
    return df

def normalizar_fecha_12h_a_24h(fecha_str):
    """
    Convierte fecha con formato 12h (p.m./a.m. o PM/AM) a formato 24h
    """
    if pd.isna(fecha_str) or fecha_str == '' or fecha_str == 'nan':
        return fecha_str
    
    fecha_str = str(fecha_str).strip()
    
    # Normalizar AM/PM (manejar p.m., pm, P.M., PM, etc.)
    # Primero extraer la parte de AM/PM
    patron_am_pm = r'\s*([ap]\.?m\.?)\s*$'
    match = re.search(patron_am_pm, fecha_str, re.IGNORECASE)
    
    if match:
        am_pm = match.group(1).upper()
        # Quitar el AM/PM del string original
        fecha_sin_ampm = re.sub(patron_am_pm, '', fecha_str, flags=re.IGNORECASE).strip()
        
        # Convertir AM/PM a formato est√°ndar
        if 'A' in am_pm.upper():
            am_pm_std = 'AM'
        elif 'P' in am_pm.upper():
            am_pm_std = 'PM'
        else:
            am_pm_std = 'AM'  # Por defecto
            
        # Reconstruir con formato est√°ndar
        fecha_str = f"{fecha_sin_ampm} {am_pm_std}"
    
    return fecha_str

# =========================
# MAIN
# =========================
def main():
    logger.info("üöÄ Iniciando merge ACLARABOT + ACLARAPP + INFOAGENTES")

    # =========================
    # CARGA ARCHIVOS
    # =========================
    aclarabot_df = cargar_csv(ACLARABOT_PATH)
    logger.info(f"‚úì Aclarabot cargado: {ACLARABOT_PATH.name} ({len(aclarabot_df)} filas)")

    aclarapp_df = cargar_csv(ACLARAPP_PATH, sep="|")
    logger.info(f"‚úì Aclarapp cargado ({len(aclarapp_df)} filas)")

    agentes_df = cargar_csv(AGENTES_PATH, sep="|")
    logger.info(f"‚úì InfoAgentes cargado ({len(agentes_df)} filas)")

    # =========================
    # AJUSTES DE COLUMNAS
    # =========================
    if "CIS" in aclarapp_df.columns:
        aclarapp_df.rename(columns={"CIS": "CIS_2"}, inplace=True)

    # =========================
    # MERGE 1: ACLARABOT + ACLARAPP
    # =========================
    merge_1 = aclarabot_df.merge(
        aclarapp_df,
        how="left",
        left_on="AclaracionID",
        right_on="ID Aclaracion",
        suffixes=("", "_DUP"),
        indicator=True
    )

    logger.info(f"Merge Aclarapp: {merge_1['_merge'].value_counts().to_dict()}")
    merge_1.drop(columns=["_merge"], inplace=True)

    # =========================
    # MERGE 2: + INFOAGENTES
    # =========================
    df_final = merge_1.merge(
        agentes_df,
        how="left",
        left_on="Numero de registro",
        right_on="ID",
        suffixes=("", "_AGENTE"),
        indicator=True
    )

    logger.info(f"Merge Agentes: {df_final['_merge'].value_counts().to_dict()}")
    df_final.drop(columns=["_merge"], inplace=True)

    # =========================
    # NORMALIZAR TODAS LAS COLUMNAS DE FECHA A FORMATO 24 HORAS
    # =========================
    logger.info("üîÑ Normalizando columnas de fecha a formato 24h...")
    
    columnas_fecha = [
        "Fecha", 
        "Fecha Creaci√≥n", 
        "Fecha Enviado", 
        "Fecha Asignacion", 
        "Fecha Atendido"
    ]
    
    for col in columnas_fecha:
        if col in df_final.columns:
            logger.info(f"  Procesando columna: {col}")
            
            # Contar valores no nulos antes
            valores_no_nulos = df_final[col].notna().sum()
            logger.info(f"    Valores a procesar: {valores_no_nulos}")
            
            # Normalizar formato 12h a est√°ndar
            df_final[col] = df_final[col].apply(normalizar_fecha_12h_a_24h)
            
            # Convertir a datetime con formato de 12 horas
            try:
                # Intentar con formato espec√≠fico primero
                df_final[col] = pd.to_datetime(
                    df_final[col],
                    format="%d/%m/%Y %I:%M:%S %p",  # %I para 12h, %p para AM/PM
                    errors="coerce"
                )
            except:
                # Si falla, intentar inferir el formato
                df_final[col] = pd.to_datetime(
                    df_final[col],
                    dayfirst=True,  # Importante para dd/mm/yyyy
                    errors="coerce"
                )
            
            # Verificar conversi√≥n
            nulos = df_final[col].isna().sum()
            convertidas = valores_no_nulos - nulos
            logger.info(f"    Fechas convertidas: {convertidas}/{valores_no_nulos}")
            
            if nulos > 0 and nulos < 10:
                # Mostrar algunas fechas problem√°ticas
                ejemplos = df_final.loc[df_final[col].isna(), col].head(3).tolist()
                logger.warning(f"    Ejemplos de fechas no convertidas: {ejemplos}")

    # =========================
    # ORDENAR POR FECHA (de m√°s antigua a m√°s actual)
    # =========================
    if "Fecha" in df_final.columns:
        logger.info(f"üìÖ Ordenando por columna 'Fecha' (de m√°s antigua a m√°s actual)")
        
        # Crear copia temporal para ordenar manteniendo nulos al final
        df_final["_temp_orden"] = df_final["Fecha"]
        
        # Ordenar (los NaN/NaT van al final por defecto)
        df_final.sort_values("_temp_orden", inplace=True, na_position="last")
        
        # Eliminar columna temporal
        df_final.drop("_temp_orden", axis=1, inplace=True)
        
        # Verificar ordenamiento
        if df_final["Fecha"].notna().sum() > 1:
            primera_fecha = df_final["Fecha"].iloc[0]
            ultima_fecha = df_final["Fecha"].iloc[-1]
            logger.info(f"  Primera fecha: {primera_fecha}")
            logger.info(f"  √öltima fecha: {ultima_fecha}")
    else:
        logger.warning("‚ö†Ô∏è No se encontr√≥ columna 'Fecha' para ordenar")

    # =========================
    # FORMATEAR FECHAS PARA SALIDA (opcional)
    # =========================
    # Si quieres que en el CSV salgan en formato dd/MM/YYYY HH:MM:SS
    for col in columnas_fecha:
        if col in df_final.columns:
            # Convertir a string con formato 24h
            df_final[col] = df_final[col].dt.strftime("%d/%m/%Y %H:%M:%S")

    # =========================
    # EXPORTAR CSV
    # =========================
    df_final.to_csv(
        OUTPUT_FILE,
        index=False,
        encoding="utf-8-sig"
    )

    logger.info("‚úÖ Archivo generado correctamente")
    logger.info(f"üìÑ {OUTPUT_FILE}")
    logger.info(f"üìä Total filas: {len(df_final)}")
    
    # Resumen de columnas de fecha
    logger.info("üìÖ Resumen de columnas de fecha:")
    for col in columnas_fecha:
        if col in df_final.columns:
            no_nulos = df_final[col].notna().sum()
            logger.info(f"  {col}: {no_nulos}/{len(df_final)} valores")

# =========================
# EJECUCI√ìN
# =========================
if __name__ == "__main__":
    main()
