import pandas as pd
import logging
from pathlib import Path
import unicodedata
import re

# =========================
# LOGGING
# =========================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# =========================
# CONFIGURACIÃ“N
# =========================
BASE_PATH = Path("c:/Copia-reporte-Aclarabot")

ACLARABOT_PATH = next(BASE_PATH.glob("*.csv"))  # ej: 06-Jan.csv
ACLARAPP_PATH = BASE_PATH / "Copy-Aclarapp" / "TablaCopiadaDeAclarapp.csv"
AGENTES_PATH = BASE_PATH / "Copy-Aclarapp" / "InfoAgentes.csv"

OUTPUT_FILE = BASE_PATH / "Acumulado_filtrado_11-Dec.csv"

# =========================
# FUNCIONES
# =========================
def normalizar_columna(col):
    col = col.strip()
    col = unicodedata.normalize("NFKD", col)
    col = col.encode("ascii", "ignore").decode("utf-8")
    return col

def cargar_csv(ruta, sep=","):
    df = pd.read_csv(
        ruta,
        sep=sep,
        dtype=str,
        encoding="utf-8-sig",
        on_bad_lines="warn"
    )
    df.columns = [normalizar_columna(c) for c in df.columns]
    df = df.apply(lambda col: col.str.strip() if col.dtype == "object" else col)
    return df

def limpiar_formato_fecha_especial(valor):
    """
    Limpia formato especial: dd/MM/yyyy hh:mm:ss p. m. (con espacio entre p. y m.)
    y a. m.
    """
    if pd.isna(valor):
        return valor
    
    valor_str = str(valor).strip()
    
    # Si el valor ya estÃ¡ vacÃ­o, regresar
    if not valor_str or valor_str.lower() in ['nan', 'nat', 'null', 'none', '']:
        return valor
    
    # DEBUG: Mostrar formato original (solo para debug)
    # logger.debug(f"  Formato original: '{valor_str}'")
    
    # PRIMERO: Corregir el espacio entre p. y m. / a. y m.
    # Patrones: "p. m." o "a. m." con cualquier cantidad de espacios
    valor_str = re.sub(r'p\.\s*m\.', 'PM', valor_str, flags=re.IGNORECASE)
    valor_str = re.sub(r'a\.\s*m\.', 'AM', valor_str, flags=re.IGNORECASE)
    
    # TambiÃ©n manejar sin puntos pero con espacio: "p m" o "a m"
    valor_str = re.sub(r'p\s+m', 'PM', valor_str, flags=re.IGNORECASE)
    valor_str = re.sub(r'a\s+m', 'AM', valor_str, flags=re.IGNORECASE)
    
    # SEGUNDO: Si todavÃ­a quedan puntos en AM/PM, quitarlos
    valor_str = re.sub(r'\bp\.m\.\b', 'PM', valor_str, flags=re.IGNORECASE)
    valor_str = re.sub(r'\ba\.m\.\b', 'AM', valor_str, flags=re.IGNORECASE)
    
    # TERCERO: Quitar espacios extra alrededor de AM/PM
    valor_str = re.sub(r'\s+([AP]M)\s*$', r' \1', valor_str)
    
    # CUARTO: Asegurar un solo espacio entre la hora y AM/PM
    valor_str = re.sub(r'(\d)\s+([AP]M)$', r'\1 \2', valor_str)
    
    # DEBUG: Mostrar formato limpiado
    # logger.debug(f"  Formato limpiado: '{valor_str}'")
    
    return valor_str.strip()

# =========================
# MAIN
# =========================
def main():
    logger.info("ðŸš€ Iniciando merge ACLARABOT + ACLARAPP + INFOAGENTES")

    # =========================
    # CARGA ARCHIVOS
    # =========================
    aclarabot_df = cargar_csv(ACLARABOT_PATH)
    logger.info(f"âœ“ Aclarabot cargado: {ACLARABOT_PATH.name} ({len(aclarabot_df)} filas)")
    
    # DEBUG: Mostrar primeras filas y formato de fecha
    if "Fecha" in aclarabot_df.columns:
        logger.info(f"ðŸ“‹ Ejemplos de formato 'Fecha' en Aclarabot (primeras 5):")
        for i in range(min(5, len(aclarabot_df))):
            fecha_ejemplo = aclarabot_df['Fecha'].iloc[i]
            logger.info(f"  Fila {i}: '{fecha_ejemplo}'")
            # Mostrar tambiÃ©n la longitud para ver espacios ocultos
            if fecha_ejemplo and str(fecha_ejemplo) != 'nan':
                logger.info(f"    Longitud: {len(str(fecha_ejemplo))} caracteres")

    aclarapp_df = cargar_csv(ACLARAPP_PATH, sep="|")
    logger.info(f"âœ“ Aclarapp cargado ({len(aclarapp_df)} filas)")

    agentes_df = cargar_csv(AGENTES_PATH, sep="|")
    logger.info(f"âœ“ InfoAgentes cargado ({len(agentes_df)} filas)")

    # =========================
    # AJUSTES DE COLUMNAS
    # =========================
    if "CIS" in aclarapp_df.columns:
        aclarapp_df.rename(columns={"CIS": "CIS_2"}, inplace=True)

    # =========================
    # MERGE 1: ACLARABOT + ACLARAPP
    # =========================
    merge_1 = aclarabot_df.merge(
        aclarapp_df,
        how="left",
        left_on="AclaracionID",
        right_on="ID Aclaracion",
        suffixes=("", "_DUP"),
        indicator=True
    )

    logger.info(f"Merge Aclarapp: {merge_1['_merge'].value_counts().to_dict()}")
    merge_1.drop(columns=["_merge"], inplace=True)

    # =========================
    # MERGE 2: + INFOAGENTES
    # =========================
    df_final = merge_1.merge(
        agentes_df,
        how="left",
        left_on="Numero de registro",
        right_on="ID",
        suffixes=("", "_AGENTE"),
        indicator=True
    )

    logger.info(f"Merge Agentes: {df_final['_merge'].value_counts().to_dict()}")
    df_final.drop(columns=["_merge"], inplace=True)

    # =========================
    # NORMALIZAR TODAS LAS COLUMNAS DE FECHA A FORMATO 24 HORAS
    # =========================
    logger.info("ðŸ”„ Normalizando columnas de fecha a formato 24h...")
    
    columnas_fecha = [
        "Fecha", 
        "Fecha CreaciÃ³n", 
        "Fecha Enviado", 
        "Fecha Asignacion", 
        "Fecha Atendido"
    ]
    
    for col in columnas_fecha:
        if col in df_final.columns:
            logger.info(f"\nðŸ“… Procesando columna: {col}")
            
            # Contar valores no nulos antes
            valores_originales = df_final[col].notna().sum()
            logger.info(f"  Valores no nulos originales: {valores_originales}")
            
            if valores_originales > 0:
                # Mostrar algunos ejemplos del formato original
                ejemplos = df_final[col].dropna().head(3).tolist()
                for i, ejemplo in enumerate(ejemplos):
                    logger.info(f"  Ejemplo {i} original: '{ejemplo}'")
            
            # PRIMERO: Aplicar limpieza especial para formato con espacio entre p. y m.
            logger.info(f"  Aplicando limpieza de formato especial...")
            df_final[col] = df_final[col].apply(limpiar_formato_fecha_especial)
            
            # Mostrar ejemplos despuÃ©s de la limpieza
            if valores_originales > 0:
                ejemplos_limpios = df_final[col].dropna().head(3).tolist()
                for i, ejemplo in enumerate(ejemplos_limpios):
                    logger.info(f"  Ejemplo {i} limpio: '{ejemplo}'")
            
            # SEGUNDO: Convertir a datetime
            logger.info(f"  Convirtiendo a datetime...")
            try:
                # Primero intentar con el formato esperado
                df_final[col] = pd.to_datetime(
                    df_final[col],
                    format="%d/%m/%Y %I:%M:%S %p",  # Formato con AM/PM
                    errors="coerce"
                )
                
                # Verificar cuÃ¡ntos se convirtieron
                convertidos_formato = df_final[col].notna().sum()
                logger.info(f"  Convertidos con formato especÃ­fico: {convertidos_formato}/{valores_originales}")
                
                # Si muchos no se convirtieron, intentar otros mÃ©todos
                if convertidos_formato < valores_originales * 0.8:  # Menos del 80%
                    logger.info(f"  Intentando parseo automÃ¡tico (dayfirst=True)...")
                    df_final[col] = pd.to_datetime(
                        df_final[col],
                        dayfirst=True,  # Importante para dd/mm/yyyy
                        errors="coerce"
                    )
                    
                # TambiÃ©n intentar sin dayfirst como Ãºltimo recurso
                if df_final[col].isna().sum() > 0:
                    no_convertidos = df_final[col].isna().sum()
                    logger.info(f"  {no_convertidos} valores no convertidos, intentando mÃ©todo flexible...")
                    
                    # Para los no convertidos, intentar uno por uno
                    for idx in df_final[df_final[col].isna()].index[:5]:  # Solo primeros 5 para debug
                        valor_original = df_final.loc[idx, col]
                        if pd.notna(valor_original):
                            logger.warning(f"    No se pudo convertir: '{valor_original}'")
                
            except Exception as e:
                logger.error(f"  Error convirtiendo {col}: {e}")
                df_final[col] = pd.to_datetime(df_final[col], errors="coerce")
            
            # Verificar conversiÃ³n final
            nulos_finales = df_final[col].isna().sum()
            convertidas_final = valores_originales - nulos_finales
            logger.info(f"  âœ… Fechas convertidas final: {convertidas_final}/{valores_originales}")
            
            if nulos_finales > 0 and nulos_finales < 10:
                # Mostrar algunas fechas problemÃ¡ticas
                logger.warning(f"  âš ï¸  {nulos_finales} fechas no convertidas")
                fechas_problematicas = df_final.loc[df_final[col].isna(), col].head(5)
                for idx, valor in fechas_problematicas.items():
                    logger.warning(f"    Ãndice {idx}: '{valor}'")

    # =========================
    # ORDENAR POR FECHA (de mÃ¡s antigua a mÃ¡s actual)
    # =========================
    if "Fecha" in df_final.columns:
        logger.info(f"\nðŸ“Š Ordenando por columna 'Fecha' (de mÃ¡s antigua a mÃ¡s actual)")
        
        # Verificar si tenemos fechas vÃ¡lidas
        fechas_validas = df_final["Fecha"].notna().sum()
        logger.info(f"  Fechas vÃ¡lidas para ordenar: {fechas_validas}/{len(df_final)}")
        
        if fechas_validas > 0:
            # Mostrar rango de fechas antes de ordenar
            fecha_min = df_final["Fecha"].min()
            fecha_max = df_final["Fecha"].max()
            logger.info(f"  Rango de fechas: {fecha_min} a {fecha_max}")
            
            # Ordenar
            df_final.sort_values("Fecha", inplace=True, na_position="last")
            
            # Verificar ordenamiento
            primera_fecha = df_final["Fecha"].iloc[0] if fechas_validas > 0 else None
            ultima_fecha_valida = df_final["Fecha"].iloc[fechas_validas-1] if fechas_validas > 0 else None
            
            logger.info(f"  Primera fecha despuÃ©s de ordenar: {primera_fecha}")
            logger.info(f"  Ãšltima fecha vÃ¡lida: {ultima_fecha_valida}")
        else:
            logger.warning("  âš ï¸ No hay fechas vÃ¡lidas para ordenar")
    else:
        logger.warning("âš ï¸ No se encontrÃ³ columna 'Fecha' para ordenar")

    # =========================
    # FORMATEAR FECHAS PARA SALIDA
    # =========================
    logger.info("\nðŸ’¾ Formateando fechas para salida CSV...")
    for col in columnas_fecha:
        if col in df_final.columns:
            # Formatear solo las fechas no nulas
            mask = df_final[col].notna()
            count_format = mask.sum()
            if count_format > 0:
                df_final.loc[mask, col] = df_final.loc[mask, col].dt.strftime("%d/%m/%Y %H:%M:%S")
                logger.info(f"  {col}: {count_format} fechas formateadas a dd/MM/YYYY HH:MM:SS")

    # =========================
    # EXPORTAR CSV
    # =========================
    logger.info(f"\nðŸ“¤ Exportando a CSV: {OUTPUT_FILE}")
    df_final.to_csv(
        OUTPUT_FILE,
        index=False,
        encoding="utf-8-sig"
    )

    logger.info("âœ… Archivo generado correctamente")
    logger.info(f"ðŸ“„ UbicaciÃ³n: {OUTPUT_FILE}")
    logger.info(f"ðŸ“Š Total filas: {len(df_final)}")
    
    # Resumen final
    logger.info("\nðŸ“Š RESUMEN FINAL:")
    logger.info("=" * 50)
    for col in columnas_fecha:
        if col in df_final.columns:
            no_nulos = df_final[col].notna().sum()
            logger.info(f"{col:<20}: {no_nulos:>5}/{len(df_final):<5} valores")
    
    logger.info("=" * 50)

# =========================
# EJECUCIÃ“N
# =========================
if __name__ == "__main__":
    main()
