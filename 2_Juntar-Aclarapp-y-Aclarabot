import pandas as pd
import logging
from pathlib import Path
import unicodedata
import re

# =========================
# LOGGING
# =========================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# =========================
# CONFIGURACI√ìN
# =========================
BASE_PATH = Path("c:/Copia-reporte-Aclarabot")

ACLARABOT_PATH = next(BASE_PATH.glob("*.csv"))  # ej: 06-Jan.csv
ACLARAPP_PATH = BASE_PATH / "Copy-Aclarapp" / "TablaCopiadaDeAclarapp.csv"
AGENTES_PATH = BASE_PATH / "Copy-Aclarapp" / "InfoAgentes.csv"

OUTPUT_FILE = BASE_PATH / "Acumulado_filtrado_11-Dec.csv"

# =========================
# FUNCIONES
# =========================
def normalizar_columna(col):
    col = col.strip()
    col = unicodedata.normalize("NFKD", col)
    col = col.encode("ascii", "ignore").decode("utf-8")
    return col

def cargar_csv(ruta, sep=","):
    df = pd.read_csv(
        ruta,
        sep=sep,
        dtype=str,
        encoding="utf-8-sig",
        on_bad_lines="warn"
    )
    df.columns = [normalizar_columna(c) for c in df.columns]
    df = df.apply(lambda col: col.str.strip() if col.dtype == "object" else col)
    return df

def limpiar_formato_fecha_especial(valor):
    """
    Limpia formato especial: dd/MM/yyyy hh:mm:ss p. m. (con espacio entre p. y m.)
    y a. m.
    """
    if pd.isna(valor):
        return valor
    
    valor_str = str(valor).strip()
    
    if not valor_str or valor_str.lower() in ['nan', 'nat', 'null', 'none', '']:
        return valor
    
    # Corregir el espacio entre p. y m. / a. y m.
    valor_str = re.sub(r'p\.\s*m\.', 'PM', valor_str, flags=re.IGNORECASE)
    valor_str = re.sub(r'a\.\s*m\.', 'AM', valor_str, flags=re.IGNORECASE)
    
    # Tambi√©n manejar sin puntos pero con espacio: "p m" o "a m"
    valor_str = re.sub(r'p\s+m', 'PM', valor_str, flags=re.IGNORECASE)
    valor_str = re.sub(r'a\s+m', 'AM', valor_str, flags=re.IGNORECASE)
    
    # Si todav√≠a quedan puntos en AM/PM, quitarlos
    valor_str = re.sub(r'\bp\.m\.\b', 'PM', valor_str, flags=re.IGNORECASE)
    valor_str = re.sub(r'\ba\.m\.\b', 'AM', valor_str, flags=re.IGNORECASE)
    
    # Quitar espacios extra alrededor de AM/PM
    valor_str = re.sub(r'\s+([AP]M)\s*$', r' \1', valor_str)
    
    # Asegurar un solo espacio entre la hora y AM/PM
    valor_str = re.sub(r'(\d)\s+([AP]M)$', r'\1 \2', valor_str)
    
    return valor_str.strip()

def procesar_fecha_aclaraapp(valor):
    """
    Procesa fecha de Aclarapp espec√≠ficamente
    Formato origen: dd/MM/yyyy hh:mm:ss AM/PM
    Formato destino: yyyy-MM-dd HH:mm:ss
    """
    if pd.isna(valor):
        return None
    
    valor_str = str(valor).strip()
    
    if not valor_str or valor_str.lower() in ['nan', 'nat', 'null', 'none', '']:
        return None
    
    logger.debug(f"Procesando fecha Aclarapp: '{valor_str}'")
    
    try:
        # PRIMERO: Limpiar formato especial si existe
        valor_limpio = limpiar_formato_fecha_especial(valor_str)
        
        # SEGUNDO: Convertir a datetime
        # Intentar primero con formato AM/PM (12 horas)
        try:
            fecha_dt = pd.to_datetime(
                valor_limpio,
                format='%d/%m/%Y %I:%M:%S %p',
                errors='raise'
            )
        except:
            # Intentar con formato 24 horas
            fecha_dt = pd.to_datetime(
                valor_limpio,
                format='%d/%m/%Y %H:%M:%S',
                errors='raise'
            )
        
        # TERCERO: Convertir a formato ISO
        fecha_iso = fecha_dt.strftime('%Y-%m-%d %H:%M:%S')
        
        logger.debug(f"  Convertido a: '{fecha_iso}'")
        return fecha_iso
        
    except Exception as e:
        logger.warning(f"Error procesando fecha Aclarapp '{valor_str}': {e}")
        
        # √öltimo intento: parseo autom√°tico
        try:
            fecha_dt = pd.to_datetime(valor_str, dayfirst=True, errors='coerce')
            if pd.notna(fecha_dt):
                return fecha_dt.strftime('%Y-%m-%d %H:%M:%S')
        except:
            pass
        
        return None

def procesar_fecha_aclarabot(valor):
    """
    Procesa fecha de Aclarabot espec√≠ficamente
    Formato destino: yyyy-MM-dd HH:mm:ss
    """
    if pd.isna(valor):
        return None
    
    valor_str = str(valor).strip()
    
    if not valor_str or valor_str.lower() in ['nan', 'nat', 'null', 'none', '']:
        return None
    
    try:
        # Limpiar formato especial si existe
        valor_limpio = limpiar_formato_fecha_especial(valor_str)
        
        # Convertir a datetime
        fecha_dt = pd.to_datetime(valor_limpio, dayfirst=True, errors='coerce')
        
        if pd.notna(fecha_dt):
            # Convertir a formato ISO
            return fecha_dt.strftime('%Y-%m-%d %H:%M:%S')
        else:
            return None
            
    except Exception as e:
        logger.warning(f"Error procesando fecha Aclarabot '{valor_str}': {e}")
        return None

def limpiar_cis(valor):
    """
    Limpia CIS para dejar solo n√∫meros
    Elimina letras, s√≠mbolos, espacios, etc.
    """
    if pd.isna(valor):
        return None
    
    valor_str = str(valor).strip()
    
    if not valor_str or valor_str.lower() in ['nan', 'nat', 'null', 'none', '']:
        return None
    
    # Eliminar todo excepto n√∫meros
    solo_numeros = re.sub(r'[^0-9]', '', valor_str)
    
    # Si despu√©s de limpiar queda vac√≠o, devolver None
    if solo_numeros == '':
        return None
    
    return solo_numeros

# =========================
# MAIN
# =========================
def main():
    logger.info("üöÄ Iniciando merge ACLARABOT + ACLARAPP + INFOAGENTES")

    # =========================
    # 1. CARGA Y PROCESAMIENTO DE ACLARAPP
    # =========================
    logger.info("\n" + "="*60)
    logger.info("1. PROCESANDO ACLARAPP")
    logger.info("="*60)
    
    aclarapp_df = cargar_csv(ACLARAPP_PATH, sep="|")
    logger.info(f"‚úì Aclarapp cargado ({len(aclarapp_df)} filas)")
    
    # Mostrar estructura de Aclarapp
    logger.info(f"Columnas en Aclarapp: {list(aclarapp_df.columns)}")
    
    # Procesar todas las fechas de Aclarapp
    columnas_fecha_aclaraapp = [
        "Fecha Creaci√≥n", 
        "Fecha Enviado", 
        "Fecha Asignacion", 
        "Fecha Atendido"
    ]
    
    logger.info("\nüìÖ PROCESANDO FECHAS DE ACLARAPP (dd/MM/yyyy hh:mm:ss AM/PM ‚Üí yyyy-MM-dd HH:mm:ss)")
    
    for col in columnas_fecha_aclaraapp:
        if col in aclarapp_df.columns:
            logger.info(f"\nProcesando: {col}")
            
            # Contar valores
            valores_antes = aclarapp_df[col].notna().sum()
            logger.info(f"  Valores no nulos: {valores_antes}")
            
            if valores_antes > 0:
                # Mostrar ejemplos ANTES
                ejemplos_antes = aclarapp_df[col].dropna().head(3).tolist()
                logger.info(f"  Ejemplos ANTES del procesamiento:")
                for i, ejemplo in enumerate(ejemplos_antes):
                    logger.info(f"    {i}: '{ejemplo}'")
                    # Mostrar tambi√©n el formato exacto
                    logger.info(f"      Longitud: {len(str(ejemplo))} chars")
                
                # Aplicar procesamiento espec√≠fico para Aclarapp
                aclarapp_df[col] = aclarapp_df[col].apply(procesar_fecha_aclaraapp)
                
                # Mostrar ejemplos DESPU√âS
                ejemplos_despues = aclarapp_df[col].dropna().head(3).tolist()
                logger.info(f"  Ejemplos DESPU√âS del procesamiento:")
                for i, ejemplo in enumerate(ejemplos_despues):
                    logger.info(f"    {i}: '{ejemplo}'")
                    # Verificar formato ISO
                    if isinstance(ejemplo, str) and re.match(r'^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$', ejemplo):
                        logger.info(f"      ‚úì Formato ISO correcto")
                    else:
                        logger.warning(f"      ‚ö†Ô∏è Formato incorrecto!")
                
                # Contar valores despu√©s
                valores_despues = aclarapp_df[col].notna().sum()
                logger.info(f"  Valores convertidos: {valores_despues}/{valores_antes}")
    
    # Limpiar columnas CIS en Aclarapp
    logger.info("\nüßπ LIMPIANDO COLUMNAS CIS EN ACLARAPP")
    if "CIS" in aclarapp_df.columns:
        logger.info(f"Procesando columna: CIS")
        
        valores_antes = aclarapp_df["CIS"].notna().sum()
        if valores_antes > 0:
            ejemplos_antes = aclarapp_df["CIS"].dropna().head(3).tolist()
            logger.info(f"  Ejemplos ANTES: {ejemplos_antes}")
            
            aclarapp_df["CIS"] = aclarapp_df["CIS"].apply(limpiar_cis)
            
            ejemplos_despues = aclarapp_df["CIS"].dropna().head(3).tolist()
            logger.info(f"  Ejemplos DESPU√âS: {ejemplos_despues}")
            
            valores_despues = aclarapp_df["CIS"].notna().sum()
            logger.info(f"  Valores antes/despu√©s: {valores_antes}/{valores_despues}")
        
        # Renombrar CIS a CIS_2
        aclarapp_df.rename(columns={"CIS": "CIS_2"}, inplace=True)
        logger.info(f"  ‚úì Columna renombrada: CIS ‚Üí CIS_2")

    # =========================
    # 2. CARGA Y PROCESAMIENTO DE ACLARABOT
    # =========================
    logger.info("\n" + "="*60)
    logger.info("2. PROCESANDO ACLARABOT")
    logger.info("="*60)
    
    aclarabot_df = cargar_csv(ACLARABOT_PATH)
    logger.info(f"‚úì Aclarabot cargado: {ACLARABOT_PATH.name} ({len(aclarabot_df)} filas)")
    
    # Procesar fecha principal de Aclarabot
    if "Fecha" in aclarabot_df.columns:
        logger.info(f"\nüìÖ PROCESANDO FECHA PRINCIPAL DE ACLARABOT")
        
        valores_originales = aclarabot_df["Fecha"].notna().sum()
        logger.info(f"  Valores no nulos: {valores_originales}")
        
        if valores_originales > 0:
            # Mostrar ejemplos originales
            ejemplos = aclarabot_df["Fecha"].dropna().head(3).tolist()
            logger.info(f"  Ejemplos originales:")
            for i, ejemplo in enumerate(ejemplos):
                logger.info(f"    {i}: '{ejemplo}'")
            
            # Aplicar procesamiento espec√≠fico para Aclarabot
            aclarabot_df["Fecha"] = aclarabot_df["Fecha"].apply(procesar_fecha_aclarabot)
            
            # Mostrar ejemplos despu√©s
            ejemplos_final = aclarabot_df["Fecha"].dropna().head(3).tolist()
            logger.info(f"  Ejemplos procesados:")
            for i, ejemplo in enumerate(ejemplos_final):
                logger.info(f"    {i}: '{ejemplo}'")

    # =========================
    # 3. CARGA DE AGENTES
    # =========================
    logger.info("\n" + "="*60)
    logger.info("3. CARGA DE INFOAGENTES")
    logger.info("="*60)
    
    agentes_df = cargar_csv(AGENTES_PATH, sep="|")
    logger.info(f"‚úì InfoAgentes cargado ({len(agentes_df)} filas)")

    # =========================
    # 4. MERGE 1: ACLARABOT + ACLARAPP
    # =========================
    logger.info("\n" + "="*60)
    logger.info("4. MERGE: ACLARABOT + ACLARAPP")
    logger.info("="*60)
    
    merge_1 = aclarabot_df.merge(
        aclarapp_df,
        how="left",
        left_on="AclaracionID",
        right_on="ID Aclaracion",
        suffixes=("", "_DUP"),
        indicator=True
    )

    logger.info(f"Resultado del merge:")
    for status, count in merge_1['_merge'].value_counts().items():
        logger.info(f"  {status}: {count}")
    
    merge_1.drop(columns=["_merge"], inplace=True)

    # =========================
    # 5. MERGE 2: + INFOAGENTES
    # =========================
    logger.info("\n" + "="*60)
    logger.info("5. MERGE: + INFOAGENTES")
    logger.info("="*60)
    
    df_final = merge_1.merge(
        agentes_df,
        how="left",
        left_on="Numero de registro",
        right_on="ID",
        suffixes=("", "_AGENTE"),
        indicator=True
    )

    logger.info(f"Resultado del merge:")
    for status, count in df_final['_merge'].value_counts().items():
        logger.info(f"  {status}: {count}")
    
    df_final.drop(columns=["_merge"], inplace=True)

    # =========================
    # 6. VERIFICACI√ìN FINAL DE FORMATOS
    # =========================
    logger.info("\n" + "="*60)
    logger.info("6. VERIFICACI√ìN FINAL DE FORMATOS")
    logger.info("="*60)
    
    # Lista de todas las columnas de fecha que deber√≠an existir
    todas_columnas_fecha = [
        "Fecha", 
        "Fecha Creaci√≥n", 
        "Fecha Enviado", 
        "Fecha Asignacion", 
        "Fecha Atendido"
    ]
    
    problemas_encontrados = []
    
    for col in todas_columnas_fecha:
        if col in df_final.columns:
            valores_no_nulos = df_final[col].notna().sum()
            logger.info(f"\n{col}:")
            logger.info(f"  Valores no nulos: {valores_no_nulos}")
            
            if valores_no_nulos > 0:
                # Tomar algunos ejemplos
                ejemplos = df_final[col].dropna().head(5).tolist()
                
                # Contar formatos correctos
                formatos_correctos = 0
                formatos_incorrectos = []
                
                for i, ejemplo in enumerate(ejemplos):
                    if isinstance(ejemplo, str):
                        # Verificar formato ISO: yyyy-MM-dd HH:mm:ss
                        if re.match(r'^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$', ejemplo):
                            formatos_correctos += 1
                            if i < 3:  # Mostrar solo primeros 3 correctos
                                logger.info(f"    ‚úì Ejemplo {i}: '{ejemplo}'")
                        else:
                            formatos_incorrectos.append((i, ejemplo))
                            if i < 3:  # Mostrar solo primeros 3 incorrectos
                                logger.warning(f"    ‚úó Ejemplo {i}: '{ejemplo}'")
                                # Intentar identificar el formato
                                if 'AM' in ejemplo.upper() or 'PM' in ejemplo.upper():
                                    logger.warning(f"      ‚ö†Ô∏è Contiene AM/PM")
                                elif '/' in ejemplo:
                                    logger.warning(f"      ‚ö†Ô∏è Formato con /")
                
                logger.info(f"  Formatos ISO correctos: {formatos_correctos}/{len(ejemplos)}")
                
                if formatos_incorrectos:
                    problemas_encontrados.append((col, formatos_incorrectos))
                    
                    # Si hay muchos problemas, forzar la conversi√≥n
                    if formatos_correctos == 0:
                        logger.warning(f"  ‚ö†Ô∏è FORZANDO CONVERSI√ìN DE {col}...")
                        if col == "Fecha":
                            df_final[col] = df_final[col].apply(procesar_fecha_aclarabot)
                        else:
                            df_final[col] = df_final[col].apply(procesar_fecha_aclaraapp)
        
        else:
            logger.warning(f"  ‚ö†Ô∏è Columna no encontrada: {col}")

    # =========================
    # 7. ORDENAR POR FECHA
    # =========================
    logger.info("\n" + "="*60)
    logger.info("7. ORDENANDO POR FECHA")
    logger.info("="*60)
    
    if "Fecha" in df_final.columns:
        # Crear columna temporal para ordenar
        df_final['_fecha_temp'] = pd.to_datetime(df_final['Fecha'], errors='coerce')
        
        fechas_validas = df_final['_fecha_temp'].notna().sum()
        logger.info(f"Fechas v√°lidas para ordenar: {fechas_validas}/{len(df_final)}")
        
        if fechas_validas > 0:
            fecha_min = df_final['_fecha_temp'].min()
            fecha_max = df_final['_fecha_temp'].max()
            logger.info(f"Rango de fechas: {fecha_min} a {fecha_max}")
            
            df_final.sort_values('_fecha_temp', inplace=True, na_position="last")
            logger.info(f"‚úì Datos ordenados por fecha")
            
            # Mostrar primera y √∫ltima fecha
            primera = df_final.iloc[0]['Fecha'] if df_final['_fecha_temp'].iloc[0] else "N/A"
            ultima_valida_idx = fechas_validas - 1 if fechas_validas > 0 else 0
            ultima = df_final.iloc[ultima_valida_idx]['Fecha'] if fechas_validas > 0 else "N/A"
            
            logger.info(f"Primera fecha: {primera}")
            logger.info(f"√öltima fecha v√°lida: {ultima}")
        
        # Eliminar columna temporal
        df_final.drop(columns=['_fecha_temp'], inplace=True)
    else:
        logger.warning("No se encontr√≥ columna 'Fecha' para ordenar")

    # =========================
    # 8. EXPORTAR CSV
    # =========================
    logger.info("\n" + "="*60)
    logger.info("8. EXPORTANDO CSV")
    logger.info("="*60)
    
    logger.info(f"Exportando a: {OUTPUT_FILE}")
    logger.info(f"Total de filas: {len(df_final)}")
    
    df_final.to_csv(
        OUTPUT_FILE,
        index=False,
        encoding="utf-8-sig"
    )
    
    logger.info("‚úÖ Archivo exportado correctamente")
    
    # Resumen final
    logger.info("\n" + "="*60)
    logger.info("RESUMEN FINAL")
    logger.info("="*60)
    
    logger.info("FORMATO FECHAS (todos deber√≠an ser yyyy-MM-dd HH:mm:ss):")
    for col in todas_columnas_fecha:
        if col in df_final.columns:
            no_nulos = df_final[col].notna().sum()
            if no_nulos > 0:
                ejemplo = df_final[col].dropna().iloc[0]
                logger.info(f"  {col:<20}: {no_nulos:>5} valores | Ej: {ejemplo}")
    
    logger.info("\nCOLUMNAS CIS:")
    if "CIS_2" in df_final.columns:
        cis_valores = df_final["CIS_2"].dropna()
        if len(cis_valores) > 0:
            ejemplo_cis = cis_valores.iloc[0]
            logger.info(f"  CIS_2: {len(cis_valores)} valores | Ej: {ejemplo_cis}")
            # Verificar que solo tenga n√∫meros
            if isinstance(ejemplo_cis, str) and re.match(r'^\d+$', ejemplo_cis):
                logger.info(f"    ‚úì Solo n√∫meros: SI")
            else:
                logger.warning(f"    ‚ö†Ô∏è Solo n√∫meros: NO")

# =========================
# EJECUCI√ìN
# =========================
if __name__ == "__main__":
    main()
