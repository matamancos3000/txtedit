import pandas as pd
import logging
from pathlib import Path
import unicodedata
import re
from datetime import datetime

# =========================
# LOGGING
# =========================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# =========================
# CONFIGURACI√ìN
# =========================
BASE_PATH = Path("c:/Copia-reporte-Aclarabot")

ACLARABOT_PATH = next(BASE_PATH.glob("*.csv"))  # ej: 06-Jan.csv
ACLARAPP_PATH = BASE_PATH / "Copy-Aclarapp" / "TablaCopiadaDeAclarapp.csv"
AGENTES_PATH = BASE_PATH / "Copy-Aclarapp" / "InfoAgentes.csv"

OUTPUT_FILE = BASE_PATH / "Acumulado_filtrado_11-Dec.csv"

# =========================
# FUNCIONES
# =========================
def normalizar_columna(col):
    col = col.strip()
    col = unicodedata.normalize("NFKD", col)
    col = col.encode("ascii", "ignore").decode("utf-8")
    return col

def cargar_csv(ruta, sep=","):
    df = pd.read_csv(
        ruta,
        sep=sep,
        dtype=str,
        encoding="utf-8-sig",
        on_bad_lines="warn"
    )
    df.columns = [normalizar_columna(c) for c in df.columns]
    df = df.apply(lambda col: col.str.strip() if col.dtype == "object" else col)
    return df

def limpiar_formato_fecha_especial(valor):
    """
    Limpia formato especial: dd/MM/yyyy hh:mm:ss p. m. (con espacio entre p. y m.)
    y a. m.
    """
    if pd.isna(valor):
        return valor
    
    valor_str = str(valor).strip()
    
    if not valor_str or valor_str.lower() in ['nan', 'nat', 'null', 'none', '']:
        return valor
    
    # Corregir el espacio entre p. y m. / a. y m.
    valor_str = re.sub(r'p\.\s*m\.', 'PM', valor_str, flags=re.IGNORECASE)
    valor_str = re.sub(r'a\.\s*m\.', 'AM', valor_str, flags=re.IGNORECASE)
    
    # Tambi√©n manejar sin puntos pero con espacio: "p m" o "a m"
    valor_str = re.sub(r'p\s+m', 'PM', valor_str, flags=re.IGNORECASE)
    valor_str = re.sub(r'a\s+m', 'AM', valor_str, flags=re.IGNORECASE)
    
    # Si todav√≠a quedan puntos en AM/PM, quitarlos
    valor_str = re.sub(r'\bp\.m\.\b', 'PM', valor_str, flags=re.IGNORECASE)
    valor_str = re.sub(r'\ba\.m\.\b', 'AM', valor_str, flags=re.IGNORECASE)
    
    # Quitar espacios extra alrededor de AM/PM
    valor_str = re.sub(r'\s+([AP]M)\s*$', r' \1', valor_str)
    
    # Asegurar un solo espacio entre la hora y AM/PM
    valor_str = re.sub(r'(\d)\s+([AP]M)$', r'\1 \2', valor_str)
    
    return valor_str.strip()

def convertir_formato_12h_a_iso(valor):
    """
    Convierte fecha de formato 12h (dd/MM/yyyy hh:mm:ss AM/PM) a ISO (yyyy-MM-dd HH:mm:ss)
    """
    if pd.isna(valor):
        return None
    
    valor_str = str(valor).strip()
    
    if not valor_str or valor_str.lower() in ['nan', 'nat', 'null', 'none', '']:
        return None
    
    logger.debug(f"Convirtiendo: '{valor_str}'")
    
    try:
        # PRIMERO: Limpiar formato especial
        valor_limpio = limpiar_formato_fecha_especial(valor_str)
        logger.debug(f"  Despu√©s de limpiar: '{valor_limpio}'")
        
        # SEGUNDO: Intentar parsear como fecha con AM/PM
        # Primero intentar con el formato exacto de Aclarapp
        try:
            fecha_dt = pd.to_datetime(
                valor_limpio,
                format='%d/%m/%Y %I:%M:%S %p',
                errors='raise'
            )
            logger.debug(f"  Parseado con formato 12h: {fecha_dt}")
        except Exception as e1:
            logger.debug(f"  Error con formato 12h: {e1}")
            
            # Intentar con formato 24h
            try:
                fecha_dt = pd.to_datetime(
                    valor_limpio,
                    format='%d/%m/%Y %H:%M:%S',
                    errors='raise'
                )
                logger.debug(f"  Parseado con formato 24h: {fecha_dt}")
            except Exception as e2:
                logger.debug(f"  Error con formato 24h: {e2}")
                
                # √öltimo intento: parseo autom√°tico
                fecha_dt = pd.to_datetime(valor_limpio, dayfirst=True, errors='coerce')
                if pd.notna(fecha_dt):
                    logger.debug(f"  Parseado autom√°tico: {fecha_dt}")
                else:
                    logger.warning(f"  No se pudo parsear: '{valor_str}'")
                    return None
        
        # TERCERO: Convertir a formato ISO
        fecha_iso = fecha_dt.strftime('%Y-%m-%d %H:%M:%S')
        logger.debug(f"  Formato ISO: '{fecha_iso}'")
        
        return fecha_iso
        
    except Exception as e:
        logger.error(f"Error en convertir_formato_12h_a_iso para '{valor_str}': {e}")
        return None

def procesar_fecha_aclarabot(valor):
    """
    Procesa fecha de Aclarabot espec√≠ficamente
    Formato destino: yyyy-MM-dd HH:mm:ss
    """
    return convertir_formato_12h_a_iso(valor)

def procesar_fecha_aclaraapp(valor):
    """
    Procesa fecha de Aclarapp espec√≠ficamente
    Formato origen: dd/MM/yyyy hh:mm:ss AM/PM
    Formato destino: yyyy-MM-dd HH:mm:ss
    """
    return convertir_formato_12h_a_iso(valor)

def limpiar_cis(valor):
    """
    Limpia CIS para dejar solo n√∫meros
    Elimina letras, s√≠mbolos, espacios, etc.
    """
    if pd.isna(valor):
        return None
    
    valor_str = str(valor).strip()
    
    if not valor_str or valor_str.lower() in ['nan', 'nat', 'null', 'none', '']:
        return None
    
    # Eliminar todo excepto n√∫meros
    solo_numeros = re.sub(r'[^0-9]', '', valor_str)
    
    # Si despu√©s de limpiar queda vac√≠o, devolver None
    if solo_numeros == '':
        return None
    
    return solo_numeros

def corregir_fecha_creacion_despues_de_exportar(df):
    """
    Funci√≥n espec√≠fica para corregir la columna 'Fecha Creaci√≥n' despu√©s del merge
    """
    if "Fecha Creaci√≥n" not in df.columns:
        logger.warning("Columna 'Fecha Creaci√≥n' no encontrada para corregir")
        return df
    
    logger.info("\n" + "="*60)
    logger.info("CORRIGIENDO COLUMNA 'FECHA CREACI√ìN' DESPU√âS DEL MERGE")
    logger.info("="*60)
    
    # Contar valores antes
    valores_antes = df["Fecha Creaci√≥n"].notna().sum()
    logger.info(f"Valores no nulos en 'Fecha Creaci√≥n': {valores_antes}")
    
    if valores_antes == 0:
        logger.info("No hay valores para corregir")
        return df
    
    # Analizar el formato actual
    ejemplos_antes = df["Fecha Creaci√≥n"].dropna().head(5).tolist()
    logger.info("Ejemplos ANTES de correcci√≥n:")
    
    formatos_detectados = set()
    for i, ejemplo in enumerate(ejemplos_antes):
        logger.info(f"  [{i}] '{ejemplo}'")
        
        # Detectar formato
        if isinstance(ejemplo, str):
            if re.search(r'\bAM\b|\bPM\b', ejemplo, re.IGNORECASE):
                formatos_detectados.add("CON_AMPM")
                logger.info(f"      ‚Üí Detectado: Contiene AM/PM")
            elif re.match(r'^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$', ejemplo):
                formatos_detectados.add("ISO")
                logger.info(f"      ‚Üí Detectado: Formato ISO correcto")
            elif '/' in ejemplo:
                formatos_detectados.add("CON_BARRAS")
                logger.info(f"      ‚Üí Detectado: Formato con /")
            else:
                formatos_detectados.add("OTRO")
                logger.info(f"      ‚Üí Detectado: Otro formato")
    
    # Aplicar correcci√≥n solo si hay fechas con AM/PM o formato incorrecto
    if "CON_AMPM" in formatos_detectados or "CON_BARRAS" in formatos_detectados:
        logger.info(f"\nAplicando correcci√≥n a 'Fecha Creaci√≥n'...")
        
        # Guardar estado original para comparaci√≥n
        estado_original = df["Fecha Creaci√≥n"].copy()
        
        # Aplicar conversi√≥n
        df["Fecha Creaci√≥n"] = df["Fecha Creaci√≥n"].apply(convertir_formato_12h_a_iso)
        
        # Contar cambios
        cambios = 0
        total = 0
        ejemplos_cambiados = []
        
        for idx in df.index:
            original = estado_original[idx]
            nuevo = df.loc[idx, "Fecha Creaci√≥n"]
            
            if pd.notna(original) and pd.notna(nuevo):
                total += 1
                if original != nuevo:
                    cambios += 1
                    if len(ejemplos_cambiados) < 3:
                        ejemplos_cambiados.append((original, nuevo))
        
        logger.info(f"Cambios realizados: {cambios}/{total}")
        
        if ejemplos_cambiados:
            logger.info("Ejemplos de cambios:")
            for i, (orig, nuevo) in enumerate(ejemplos_cambiados):
                logger.info(f"  [{i}] '{orig}' ‚Üí '{nuevo}'")
        
        # Verificar formato despu√©s
        ejemplos_despues = df["Fecha Creaci√≥n"].dropna().head(3).tolist()
        logger.info("\nEjemplos DESPU√âS de correcci√≥n:")
        formatos_correctos = 0
        for i, ejemplo in enumerate(ejemplos_despues):
            if isinstance(ejemplo, str) and re.match(r'^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$', ejemplo):
                formatos_correctos += 1
                logger.info(f"  [{i}] '{ejemplo}' ‚úì")
            else:
                logger.warning(f"  [{i}] '{ejemplo}' ‚úó")
        
        logger.info(f"Formatos ISO correctos despu√©s: {formatos_correctos}/{len(ejemplos_despues)}")
    else:
        logger.info("No se necesita correcci√≥n - todas las fechas ya est√°n en formato correcto")
    
    return df

# =========================
# MAIN
# =========================
def main():
    logger.info("üöÄ Iniciando merge ACLARABOT + ACLARAPP + INFOAGENTES")

    # =========================
    # 1. CARGA Y PROCESAMIENTO DE ACLARAPP
    # =========================
    logger.info("\n" + "="*60)
    logger.info("1. PROCESANDO ACLARAPP")
    logger.info("="*60)
    
    aclarapp_df = cargar_csv(ACLARAPP_PATH, sep="|")
    logger.info(f"‚úì Aclarapp cargado ({len(aclarapp_df)} filas)")
    
    # Procesar todas las fechas de Aclarapp
    columnas_fecha_aclaraapp = [
        "Fecha Creaci√≥n", 
        "Fecha Enviado", 
        "Fecha Asignacion", 
        "Fecha Atendido"
    ]
    
    logger.info("\nüìÖ PROCESANDO FECHAS DE ACLARAPP")
    
    for col in columnas_fecha_aclaraapp:
        if col in aclarapp_df.columns:
            logger.info(f"\nProcesando: {col}")
            
            valores_antes = aclarapp_df[col].notna().sum()
            logger.info(f"  Valores no nulos: {valores_antes}")
            
            if valores_antes > 0:
                # Aplicar procesamiento
                aclarapp_df[col] = aclarapp_df[col].apply(procesar_fecha_aclaraapp)
                
                # Verificar
                valores_despues = aclarapp_df[col].notna().sum()
                logger.info(f"  Valores convertidos: {valores_despues}/{valores_antes}")
    
    # Limpiar y renombrar CIS
    if "CIS" in aclarapp_df.columns:
        aclarapp_df["CIS"] = aclarapp_df["CIS"].apply(limpiar_cis)
        aclarapp_df.rename(columns={"CIS": "CIS_2"}, inplace=True)

    # =========================
    # 2. CARGA Y PROCESAMIENTO DE ACLARABOT
    # =========================
    logger.info("\n" + "="*60)
    logger.info("2. PROCESANDO ACLARABOT")
    logger.info("="*60)
    
    aclarabot_df = cargar_csv(ACLARABOT_PATH)
    logger.info(f"‚úì Aclarabot cargado: {ACLARABOT_PATH.name} ({len(aclarabot_df)} filas)")
    
    if "Fecha" in aclarabot_df.columns:
        logger.info(f"\nüìÖ PROCESANDO FECHA PRINCIPAL DE ACLARABOT")
        valores_originales = aclarabot_df["Fecha"].notna().sum()
        aclarabot_df["Fecha"] = aclarabot_df["Fecha"].apply(procesar_fecha_aclarabot)
        valores_convertidos = aclarabot_df["Fecha"].notna().sum()
        logger.info(f"  Convertidos: {valores_convertidos}/{valores_originales}")

    # =========================
    # 3. CARGA DE AGENTES
    # =========================
    logger.info("\n" + "="*60)
    logger.info("3. CARGA DE INFOAGENTES")
    logger.info("="*60)
    
    agentes_df = cargar_csv(AGENTES_PATH, sep="|")
    logger.info(f"‚úì InfoAgentes cargado ({len(agentes_df)} filas)")

    # =========================
    # 4. MERGE 1: ACLARABOT + ACLARAPP
    # =========================
    logger.info("\n" + "="*60)
    logger.info("4. MERGE: ACLARABOT + ACLARAPP")
    logger.info("="*60)
    
    merge_1 = aclarabot_df.merge(
        aclarapp_df,
        how="left",
        left_on="AclaracionID",
        right_on="ID Aclaracion",
        suffixes=("", "_DUP"),
        indicator=True
    )

    logger.info(f"Resultado del merge:")
    for status, count in merge_1['_merge'].value_counts().items():
        logger.info(f"  {status}: {count}")
    
    merge_1.drop(columns=["_merge"], inplace=True)

    # =========================
    # 5. MERGE 2: + INFOAGENTES
    # =========================
    logger.info("\n" + "="*60)
    logger.info("5. MERGE: + INFOAGENTES")
    logger.info("="*60)
    
    df_final = merge_1.merge(
        agentes_df,
        how="left",
        left_on="Numero de registro",
        right_on="ID",
        suffixes=("", "_AGENTE"),
        indicator=True
    )

    logger.info(f"Resultado del merge:")
    for status, count in df_final['_merge'].value_counts().items():
        logger.info(f"  {status}: {count}")
    
    df_final.drop(columns=["_merge"], inplace=True)

    # =========================
    # 6. CORREGIR 'FECHA CREACI√ìN' DESPU√âS DEL MERGE
    # =========================
    df_final = corregir_fecha_creacion_despues_de_exportar(df_final)

    # =========================
    # 7. VERIFICAR TODAS LAS FECHAS
    # =========================
    logger.info("\n" + "="*60)
    logger.info("7. VERIFICACI√ìN DE TODAS LAS FECHAS")
    logger.info("="*60)
    
    todas_columnas_fecha = [
        "Fecha", 
        "Fecha Creaci√≥n", 
        "Fecha Enviado", 
        "Fecha Asignacion", 
        "Fecha Atendido"
    ]
    
    for col in todas_columnas_fecha:
        if col in df_final.columns:
            valores_no_nulos = df_final[col].notna().sum()
            
            if valores_no_nulos > 0:
                # Tomar ejemplos
                ejemplos = df_final[col].dropna().head(3).tolist()
                
                # Verificar formato
                formatos_correctos = 0
                for i, ejemplo in enumerate(ejemplos):
                    if isinstance(ejemplo, str) and re.match(r'^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$', ejemplo):
                        formatos_correctos += 1
                        if i == 0:  # Solo mostrar el primer ejemplo si es correcto
                            logger.info(f"{col:<20}: {valores_no_nulos:>5} ‚úì Ej: '{ejemplo}'")
                    else:
                        # Mostrar todos los ejemplos incorrectos
                        logger.warning(f"{col:<20}: [{i}] '{ejemplo}' ‚úó")
                
                if formatos_correctos == len(ejemplos) and len(ejemplos) > 0:
                    pass  # Ya se mostr√≥ arriba
                elif formatos_correctos > 0:
                    logger.info(f"{col:<20}: {valores_no_nulos:>5} ({formatos_correctos}/{len(ejemplos)} correctos)")
                else:
                    logger.warning(f"{col:<20}: {valores_no_nulos:>5} (0/{len(ejemplos)} correctos)")

    # =========================
    # 8. ORDENAR POR FECHA
    # =========================
    logger.info("\n" + "="*60)
    logger.info("8. ORDENANDO POR FECHA")
    logger.info("="*60)
    
    if "Fecha" in df_final.columns:
        # Crear columna temporal para ordenar
        df_final['_fecha_temp'] = pd.to_datetime(df_final['Fecha'], errors='coerce')
        
        fechas_validas = df_final['_fecha_temp'].notna().sum()
        if fechas_validas > 0:
            df_final.sort_values('_fecha_temp', inplace=True, na_position="last")
            logger.info(f"‚úì Ordenado por fecha ({fechas_validas} fechas v√°lidas)")
        else:
            logger.warning("‚ö†Ô∏è No hay fechas v√°lidas para ordenar")
        
        # Eliminar columna temporal
        df_final.drop(columns=['_fecha_temp'], inplace=True)
    else:
        logger.warning("No se encontr√≥ columna 'Fecha' para ordenar")

    # =========================
    # 9. EXPORTAR CSV TEMPORAL
    # =========================
    logger.info("\n" + "="*60)
    logger.info("9. EXPORTANDO CSV TEMPORAL")
    logger.info("="*60)
    
    # Guardar temporalmente
    TEMP_FILE = BASE_PATH / "temp_export.csv"
    logger.info(f"Guardando archivo temporal: {TEMP_FILE}")
    
    df_final.to_csv(
        TEMP_FILE,
        index=False,
        encoding="utf-8-sig"
    )
    
    logger.info(f"‚úì Archivo temporal guardado ({len(df_final)} filas)")

    # =========================
    # 10. LECTURA Y CORRECCI√ìN FINAL
    # =========================
    logger.info("\n" + "="*60)
    logger.info("10. LECTURA Y CORRECCI√ìN FINAL")
    logger.info("="*60)
    
    # Leer el archivo temporal para asegurar formato limpio
    logger.info("Leyendo archivo temporal para correcci√≥n final...")
    df_corregido = pd.read_csv(
        TEMP_FILE,
        dtype=str,
        encoding="utf-8-sig"
    )
    
    # Aplicar correcci√≥n FINAL a 'Fecha Creaci√≥n'
    logger.info("\nAPLICANDO CORRECCI√ìN FINAL A 'FECHA CREACI√ìN'...")
    
    if "Fecha Creaci√≥n" in df_corregido.columns:
        valores_totales = len(df_corregido)
        valores_no_nulos = df_corregido["Fecha Creaci√≥n"].notna().sum()
        
        logger.info(f"Total de filas: {valores_totales}")
        logger.info(f"Fechas no nulas: {valores_no_nulos}")
        
        if valores_no_nulos > 0:
            # Mostrar estado actual
            ejemplos_actuales = df_corregido["Fecha Creaci√≥n"].dropna().head(5).tolist()
            logger.info("Estado ACTUAL de 'Fecha Creaci√≥n':")
            
            for i, ejemplo in enumerate(ejemplos_actuales):
                logger.info(f"  [{i}] '{ejemplo}'")
                
                # Verificar si necesita conversi√≥n
                necesita_conversion = False
                if isinstance(ejemplo, str):
                    if re.search(r'\bAM\b|\bPM\b', ejemplo, re.IGNORECASE):
                        necesita_conversion = True
                        logger.info(f"      ‚Üí Necesita conversi√≥n (tiene AM/PM)")
                    elif not re.match(r'^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$', ejemplo):
                        if '/' in ejemplo:
                            necesita_conversion = True
                            logger.info(f"      ‚Üí Necesita conversi√≥n (formato con /)")
            
            # Aplicar conversi√≥n SI es necesario
            if necesita_conversion:
                logger.info("\nAplicando conversi√≥n final...")
                
                # Contador para seguimiento
                convertidos = 0
                no_convertidos = 0
                ejemplos_conversion = []
                
                for idx in df_corregido.index:
                    valor_original = df_corregido.loc[idx, "Fecha Creaci√≥n"]
                    
                    if pd.notna(valor_original):
                        nuevo_valor = convertir_formato_12h_a_iso(valor_original)
                        
                        if nuevo_valor is not None:
                            df_corregido.loc[idx, "Fecha Creaci√≥n"] = nuevo_valor
                            convertidos += 1
                            
                            if len(ejemplos_conversion) < 3 and valor_original != nuevo_valor:
                                ejemplos_conversion.append((valor_original, nuevo_valor))
                        else:
                            no_convertidos += 1
                
                logger.info(f"Fechas convertidas: {convertidos}")
                logger.info(f"Fechas no convertidas: {no_convertidos}")
                
                if ejemplos_conversion:
                    logger.info("Ejemplos de conversi√≥n:")
                    for i, (orig, nuevo) in enumerate(ejemplos_conversion):
                        logger.info(f"  [{i}] '{orig}' ‚Üí '{nuevo}'")
                
                # Verificar formato despu√©s
                ejemplos_finales = df_corregido["Fecha Creaci√≥n"].dropna().head(3).tolist()
                logger.info("\nFormato FINAL de 'Fecha Creaci√≥n':")
                
                for i, ejemplo in enumerate(ejemplos_finales):
                    if isinstance(ejemplo, str) and re.match(r'^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$', ejemplo):
                        logger.info(f"  [{i}] '{ejemplo}' ‚úì")
                    else:
                        logger.warning(f"  [{i}] '{ejemplo}' ‚úó")
            else:
                logger.info("‚úì No se necesita conversi√≥n - formato ya es correcto")
    
    # =========================
    # 11. EXPORTAR CSV FINAL
    # =========================
    logger.info("\n" + "="*60)
    logger.info("11. EXPORTANDO CSV FINAL")
    logger.info("="*60)
    
    logger.info(f"Exportando a: {OUTPUT_FILE}")
    
    df_corregido.to_csv(
        OUTPUT_FILE,
        index=False,
        encoding="utf-8-sig"
    )
    
    # Eliminar archivo temporal
    if TEMP_FILE.exists():
        TEMP_FILE.unlink()
        logger.info("‚úì Archivo temporal eliminado")
    
    logger.info("‚úÖ Archivo FINAL exportado correctamente")
    
    # Resumen final
    logger.info("\n" + "="*60)
    logger.info("RESUMEN FINAL")
    logger.info("="*60)
    
    logger.info(f"Archivo: {OUTPUT_FILE}")
    logger.info(f"Total filas: {len(df_corregido)}")
    
    logger.info("\nFORMATO DE FECHAS (todos en yyyy-MM-dd HH:mm:ss):")
    for col in todas_columnas_fecha:
        if col in df_corregido.columns:
            no_nulos = df_corregido[col].notna().sum()
            if no_nulos > 0:
                ejemplo = df_corregido[col].dropna().iloc[0]
                # Verificar formato
                if isinstance(ejemplo, str) and re.match(r'^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$', ejemplo):
                    logger.info(f"  {col:<20}: {no_nulos:>5} ‚úì Ej: {ejemplo}")
                else:
                    logger.warning(f"  {col:<20}: {no_nulos:>5} ‚úó Ej: '{ejemplo}'")

# =========================
# EJECUCI√ìN
# =========================
if __name__ == "__main__":
    main()
