import os
import pandas as pd
import matplotlib.pyplot as plt
from openpyxl import Workbook
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.styles import Font, PatternFill
from openpyxl.drawing.image import Image as XLImage
from datetime import datetime
import time

# ================= CONFIGURACIÃ“N =================
CARPETA_LOGS = r"C:\Logs-Reporttoken"
OUTPUT_FILE = "ReporteLogs.xlsx"
ENVIAR_CORREO = False  # ðŸš© Cambia a True si quieres enviar el correo
# ==================================================

def limpiar_detalles(valor):
    if pd.isna(valor) or str(valor).strip() == "":
        return "Error de sistema"
    valor = str(valor).lower()
    if "aprobado" in valor:
        return "Aprobado por otro medio"
    if "error" in valor:
        return "Error de sistema"
    return valor.title()

def procesar_logs():
    archivos = [f for f in os.listdir(CARPETA_LOGS) if f.endswith(".csv")]
    if not archivos:
        print("No se encontraron archivos CSV en la carpeta.")
        return

    df_total = pd.DataFrame()

    # ==== Procesamiento con porcentaje ====
    total_archivos = len(archivos)
    for idx, archivo in enumerate(archivos, 1):
        ruta = os.path.join(CARPETA_LOGS, archivo)
        df = pd.read_csv(ruta)

        # NormalizaciÃ³n de fechas
        for col in ["CreatedOn", "FECHA DE TRABAJO", "FECHA DE NACIMIENTO"]:
            if col in df.columns:
                df[col] = pd.to_datetime(df[col], errors="coerce", dayfirst=True)

        # Minutos de respuesta
        if "CreatedOn" in df.columns and "FECHA DE TRABAJO" in df.columns:
            df["MinutosRespuesta"] = (df["FECHA DE TRABAJO"] - df["CreatedOn"]).dt.total_seconds() / 60
        else:
            df["MinutosRespuesta"] = None

        # Intervalos
        def clasificar_intervalo(mins):
            if pd.isna(mins): return "Sin dato"
            if mins <= 10: return "Menos de 10 minutos"
            if mins <= 20: return "De 11 a 20 minutos"
            if mins <= 30: return "De 21 a 30 minutos"
            return "MÃ¡s de 30 minutos"

        df["Intervalo"] = df["MinutosRespuesta"].apply(clasificar_intervalo)

        # Limpieza de detalles
        if "DETALLES" in df.columns:
            df["DETALLES"] = df["DETALLES"].apply(limpiar_detalles)

        df_total = pd.concat([df_total, df], ignore_index=True)

        print(f"Procesando {archivo}... {round((idx/total_archivos)*100,2)}% completado")

    # === Ordenar logs por CreatedOn ===
    if "CreatedOn" in df_total.columns:
        df_total = df_total.sort_values(by="CreatedOn", ascending=True)

    # === Pivot Resumen ===
    if "CreatedOn" in df_total.columns:
        df_total["Fecha"] = df_total["CreatedOn"].dt.date
    else:
        df_total["Fecha"] = None

    resumen = pd.pivot_table(
        df_total,
        values="ProgramID" if "ProgramID" in df_total.columns else None,
        index="Fecha",
        columns="Intervalo",
        aggfunc="count",
        fill_value=0
    ).reset_index()

    # ðŸ”¹ Ordenar resumen por fecha
    resumen = resumen.sort_values(by="Fecha", ascending=True)

    # ==== Exportar a Excel ====
    wb = Workbook()
    ws_logs = wb.active
    ws_logs.title = "Logs"

    # Insertar logs
    for r in dataframe_to_rows(df_total, index=False, header=True):
        ws_logs.append(r)

    # Estilos Logs
    for cell in ws_logs[1]:
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")

    # Hoja Resumen
    ws_resumen = wb.create_sheet("Resumen")
    for r in dataframe_to_rows(resumen, index=False, header=True):
        ws_resumen.append(r)

    for cell in ws_resumen[1]:
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")

    # ==== GrÃ¡fica ====
    if not resumen.empty:
        resumen.set_index("Fecha", inplace=True)

        ax = resumen.plot(kind="bar", stacked=True, figsize=(34/2.54, 17/2.54))  # cm â†’ pulgadas
        plt.title("DistribuciÃ³n de Intervalos por Fecha")
        plt.xlabel("Fecha")
        plt.ylabel("Cantidad")
        plt.tight_layout()
        plt.savefig("grafico.png")
        plt.close()

        img = XLImage("grafico.png")
        ws_resumen.add_image(img, "H5")

    wb.save(OUTPUT_FILE)
    print(f"Archivo generado: {OUTPUT_FILE}")

    # ==== EnvÃ­o de correo (opcional) ====
    if ENVIAR_CORREO:
        try:
            from tresenviarcorreo import generar_correo, seleccionar_confidencialidad_y_enviar
            generar_correo(OUTPUT_FILE)
            seleccionar_confidencialidad_y_enviar()
            print("Correo enviado âœ…")
        except Exception as e:
            print(f"Error al enviar correo: {e}")

if __name__ == "__main__":
    inicio = time.time()
    procesar_logs()
    fin = time.time()
    print(f"Tiempo total de ejecuciÃ³n: {round(fin-inicio,2)} segundos")
