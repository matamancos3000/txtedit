import os
import pandas as pd
import re
from datetime import datetime, timedelta
from openpyxl import load_workbook
from openpyxl.styles import Font, PatternFill, Alignment
from openpyxl.chart import BarChart, Reference
from openpyxl.chart.series import DataPoint
from tresenviarcorreo import generar_correo, seleccionar_confidencialidad_y_enviar

# === CONFIGURACI√ìN ===
input_folder = r"C:\Logs-Reporttoken"
output_folder = r"C:\Logs-Reporttoken\Procesados"
os.makedirs(output_folder, exist_ok=True)

ENVIAR_CORREO = True  # <<< Cambia a False si NO quieres enviar correo

# === FUNCIONES AUXILIARES ===
def parse_fecha_trabajo(valor):
    if pd.isna(valor):
        return None
    for fmt in ("%d/%m/%Y %H:%M:%S", "%d/%m/%Y %H:%M"):
        try:
            return datetime.strptime(str(valor), fmt)
        except:
            continue
    return None

def parse_fecha_nac(valor):
    if pd.isna(valor):
        return None
    valor = str(valor).lower().replace("a. m.", "AM").replace("p. m.", "PM")
    for fmt in ("%d/%m/%Y %I:%M:%S %p", "%d/%m/%Y %I:%M %p", "%d/%m/%Y"):
        try:
            return datetime.strptime(valor, fmt)
        except:
            continue
    return None

def calcular_minutos(row):
    created, trabajado = row.get("CreatedOn"), row.get("FECHA DE TRABAJO")
    if pd.isna(created) or trabajado is None:
        return None
    if created.hour >= 22 or created.hour < 6:
        return "Horario bot inactivo"
    return round((trabajado - created).total_seconds() / 60)

def clasificar_intervalo(valor):
    if isinstance(valor, str):
        return valor
    if pd.isna(valor):
        return None
    if valor <= 10:
        return "menos de 10 minutos"
    elif valor <= 20:
        return "de 11 a 20 minutos"
    elif valor <= 30:
        return "de 21 a 30 minutos"
    elif valor <= 60:
        return "de 30 a 60 minutos"
    else:
        return "m√°s de 60 minutos"

def limpiar_detalles(texto):
    # Si no es string o est√° vac√≠o -> Error de sistema
    if not isinstance(texto, str):
        return "Error de sistema"
    texto = texto.strip()
    if texto == "":
        return "Error de sistema"
    if re.match(r"^El restablecimiento fuera de l√≠nea no se pudo completar por estado: 'Aprobado'", texto, re.IGNORECASE):
        return "Aprobado por otro medio"
    elif re.match(r"^El restablecimiento fuera de l√≠nea no se pudo completar por estado:", texto, re.IGNORECASE):
        return "No tiene Solicitud vigente"
    elif re.search(r"Error de sistema", texto, re.IGNORECASE):
        return "Error de sistema"
    elif re.match(r"^Productos y Servicios.*", texto, re.IGNORECASE):
        return "Error en obtener registro por voz"
    return texto

def mostrar_progreso(paso, total_pasos, archivo):
    porcentaje = round((paso / total_pasos) * 100, 2)
    print(f"   üìÇ Generando {archivo}... {porcentaje}%")

# === PROCESAR TODOS LOS CSV ===
archivos = [f for f in os.listdir(input_folder) if f.lower().endswith(".csv")]
total = len(archivos)

for idx, file in enumerate(archivos, start=1):
    porcentaje = round((idx / total) * 100, 2)
    print(f"üîÑ Procesando {file}... ({idx}/{total}, {porcentaje}%)")

    input_file = os.path.join(input_folder, file)
    output_file = os.path.join(output_folder, file.replace(".csv", "-procesado.xlsx"))

    # === LEER ARCHIVO ===
    df = pd.read_csv(input_file, encoding="utf-8-sig", dtype={"MSISDN": str})

    # Validar columnas m√≠nimas
    columnas_necesarias = ["CreatedOn", "FECHA DE TRABAJO", "FECHA DE NACIMIENTO", "DETALLES"]
    for col in columnas_necesarias:
        if col not in df.columns:
            raise ValueError(f"‚ùå Falta la columna requerida: {col}")

    # === PARSEAR FECHAS ===
    df["CreatedOn"] = pd.to_datetime(df["CreatedOn"], format="%b %d %Y %I:%M%p", errors="coerce") + timedelta(hours=6)
    df["FECHA DE TRABAJO"] = df["FECHA DE TRABAJO"].apply(parse_fecha_trabajo)
    df["FECHA DE NACIMIENTO"] = df["FECHA DE NACIMIENTO"].apply(parse_fecha_nac)

    # === CALCULOS ===
    df["Minutos de respuesta"] = df.apply(calcular_minutos, axis=1)
    df["Intervalo"] = df["Minutos de respuesta"].apply(clasificar_intervalo)

    # DETALLES vac√≠o ‚Üí Error de sistema (limpiar_detalles lo cubre)
    df["DETALLES"] = df["DETALLES"].apply(limpiar_detalles)

    # ORDENAR LOGS POR CreatedOn (fecha + hora reales)
    df["Fecha"] = df["CreatedOn"].dt.date
    df = df.sort_values(by="CreatedOn", ascending=True)

    # === RESUMEN POR D√çA + INTERVALO ===
    pivot = pd.pivot_table(
        df,
        index="Fecha",
        columns="Intervalo",
        values="MSISDN",
        aggfunc="count",
        fill_value=0
    )
    orden_intervalos = [
        "menos de 10 minutos", "de 11 a 20 minutos",
        "de 21 a 30 minutos", "de 30 a 60 minutos",
        "m√°s de 60 minutos", "Horario bot inactivo"
    ]
    pivot = pivot.reindex(columns=orden_intervalos, fill_value=0)
    pivot["Total"] = pivot.sum(axis=1)
    pivot = pivot.sort_index(ascending=True)  # asegurar orden cronol√≥gico

    # === RESUMEN POR DETALLES ===
    resumen_detalles = df["DETALLES"].value_counts().reset_index()
    resumen_detalles.columns = ["DETALLES", "Cantidad"]

    # === TOP 18 MSISDN ===
    top_msisdn = df["MSISDN"].value_counts().head(18).reset_index()
    top_msisdn.columns = ["MSISDN", "Cantidad"]

    # === EXPORTAR A EXCEL ===
    pasos_totales = 5
    paso_actual = 0

    # 1) Exportar datos (Logs + Resumen + Detalles + Top MSISDN)
    with pd.ExcelWriter(output_file, engine="openpyxl",
                        date_format="DD/MM/YYYY HH:MM:SS",
                        datetime_format="DD/MM/YYYY HH:MM:SS") as writer:
        df.to_excel(writer, sheet_name="Logs", index=False)

        # Pivot (Resumen)
        pivot.to_excel(writer, sheet_name="Resumen", startrow=0, index=True)

        # Resumen de DETALLES (encabezado en la fila pivot.shape[0] + 5)
        start_row_detalles = pivot.shape[0] + 4
        resumen_detalles.to_excel(writer, sheet_name="Resumen", startrow=start_row_detalles, index=False)

        # Top MSISDN al lado (columna D, startcol=3 -> columna D)
        top_msisdn.to_excel(writer, sheet_name="Resumen", startrow=start_row_detalles, startcol=3, index=False)

    paso_actual += 1
    mostrar_progreso(paso_actual, pasos_totales, file)

    # 2) Formato Logs
    wb = load_workbook(output_file)
    ws_logs = wb["Logs"]
    for cell in ws_logs[1]:
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")
    paso_actual += 1
    mostrar_progreso(paso_actual, pasos_totales, file)

    # 3) Formato Resumen (encabezados pivot)
    ws_resumen = wb["Resumen"]
    for cell in ws_resumen[1]:
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")

    # üëâ Justificar columna A (Fecha) un poco a la izquierda ‚Äî aqu√≠ est√° el ajuste que pediste
    for cell in ws_resumen["A"]:
        cell.alignment = Alignment(horizontal="left")

    # Estilo para encabezados de Resumen DETALLES y Top MSISDN (misma fila)
    encabezado_detalles_row = pivot.shape[0] + 5  # fila Excel donde quedaron los encabezados de resumen_detalles
    for cell in ws_resumen[encabezado_detalles_row]:
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")

    paso_actual += 1
    mostrar_progreso(paso_actual, pasos_totales, file)

    # 4) Insertar gr√°fica con colores (asignamos color por posici√≥n seg√∫n pivot.columns)
    max_row = pivot.shape[0] + 1
    max_col = pivot.shape[1] + 1
    chart = BarChart()
    data = Reference(ws_resumen, min_col=2, max_col=max_col, min_row=1, max_row=max_row)
    cats = Reference(ws_resumen, min_col=1, min_row=2, max_row=max_row)
    chart.add_data(data, titles_from_data=True)
    chart.set_categories(cats)
    chart.title = "Distribuci√≥n por Intervalos (diario)"
    chart.y_axis.title = "Cantidad"
    chart.x_axis.title = "Fecha"
    chart.width = 34   # Nuevo tama√±o ancho (cm aprox)
    chart.height = 17  # Nuevo tama√±o alto (cm aprox)

    # Colores personalizados (hex sin '#')
    colores_intervalos = {
        "menos de 10 minutos": "00B050",   # verde
        "de 11 a 20 minutos": "92D050",    # verde claro
        "de 21 a 30 minutos": "FFFF00",    # amarillo
        "de 30 a 60 minutos": "ED7D31",    # naranja
        "m√°s de 60 minutos": "FF0000",     # rojo
        "Horario bot inactivo": "000000",  # negro
        "Total": "808080"                  # gris
    }

    # Asignar colores por posici√≥n (robusto y compatible)
    series_names = list(pivot.columns)  # orden exacto de las columnas del pivot
    for i, serie in enumerate(chart.series):
        if i < len(series_names):
            nombre_serie = series_names[i]
            color = colores_intervalos.get(nombre_serie)
            if color:
                try:
                    # M√©todo preferible: colorear la serie completa
                    serie.graphicalProperties.solidFill = color
                except Exception:
                    # Fallback: colorear por DataPoint (si alguna versi√≥n lo requiere)
                    dp = DataPoint(idx=0)
                    dp.graphicalProperties.solidFill = color
                    serie.dPt = [dp]

    ws_resumen.add_chart(chart, f"I2")
    paso_actual += 1
    mostrar_progreso(paso_actual, pasos_totales, file)

    # 5) Guardar
    wb.save(output_file)
    paso_actual += 1
    mostrar_progreso(paso_actual, pasos_totales, file)

    print(f"‚úÖ Archivo generado: {output_file}\n")

    # === ENV√çO DE CORREO (opcional) ===
    if ENVIAR_CORREO:
        generar_correo(output_file)
        seleccionar_confidencialidad_y_enviar()
