import re
from pathlib import Path
import shutil
import os
import csv

# ================== CONFIGURACI√ìN ==================
CARPETA_RAIZ = Path(r"C:\Users\45056372\Desktop\prueba its\calidad2025")
CARPETA_DE_RECURSOS = "Formatos2021"
URL_SHAREPOINT = "https://teams.global.hsbc/sites/labpspyas-2019/CALIDAD20251/"
LOG_CSV = CARPETA_RAIZ.parent / "log_cambios.csv"


# ================== FUNCIONES ==================
def convertir_enlaces(contenido, ruta_html):
    """
    Convierte enlaces dentro de un HTML:
    - .htm/.html -> .pdf en SharePoint (si contienen 'calidad2021/' o si son relativos dentro del √°rbol).
    - Documentos (docx,xlsx,..) -> si contienen 'calidad2021/Formatos2021/'.
    - No tocar enlaces que apunten a carpetas *_archivos (para no romper im√°genes).
    - Conserva fragmentos (#ancla).
    - Intenta resolver enlaces relativos sin '/' respecto a la ubicaci√≥n del html dentro de CARPETA_RAIZ.
    """
    cambios = []

    def reemplazar_enlace(match):
        comilla = match.group(1)
        enlace = match.group(2)  # sin comillas
        enlace_norm = enlace.replace("\\", "/")

        # separar fragmento (#...) si existe y mantenerlo
        if "#" in enlace_norm:
            ruta_sin_fragmento, fragmento = enlace_norm.split("#", 1)
            fragmento = "#" + fragmento
        else:
            ruta_sin_fragmento, fragmento = enlace_norm, ""

        # ignorar si apunta a carpeta de recursos *_archivos
        if "_archivos/" in ruta_sin_fragmento.lower() or "_archivos\\" in ruta_sin_fragmento.lower():
            return match.group(0)

        nombre_base, extension = os.path.splitext(os.path.basename(ruta_sin_fragmento))
        extension = extension.lower()

        # ----- Caso: .htm/.html -----
        if extension in [".htm", ".html"]:
            # 1) Si contiene "calidad2021/" anywhere -> tomar lo que venga despu√©s y usarlo
            m = re.search(r'calidad2021/', ruta_sin_fragmento, flags=re.IGNORECASE)
            if m:
                suffix = ruta_sin_fragmento[m.end():]  # conserva may√∫sc/min√∫sc del resto
                # construir ruta .pdf respetando subcarpetas
                ruta_relativa = Path(suffix).with_suffix(".pdf").as_posix()
                nuevo = f"{URL_SHAREPOINT}{ruta_relativa}{fragmento}"
                cambios.append((enlace, nuevo, "HTML->PDF"))
                return f'href={comilla}{nuevo}{comilla}'

            # 2) Si es absoluto dentro del sitio (empieza con '/') -> quitar '/' y usar como ruta en sharepoint
            if ruta_sin_fragmento.startswith("/"):
                ruta_relativa = Path(ruta_sin_fragmento.lstrip("/")).with_suffix(".pdf").as_posix()
                nuevo = f"{URL_SHAREPOINT}{ruta_relativa}{fragmento}"
                cambios.append((enlace, nuevo, "HTML->PDF (raiz)"))
                return f'href={comilla}{nuevo}{comilla}'

            # 3) Si es relativo (p.ej. "OTRO.htm" o "../carp/otro.htm") -> intentar resolver respecto al html actual y luego a CARPETA_RAIZ
            try:
                posible = (ruta_html.parent / ruta_sin_fragmento).resolve()
                # solo si est√° dentro de CARPETA_RAIZ, convertir a ruta relativa
                try:
                    rel = posible.relative_to(CARPETA_RAIZ)
                    ruta_relativa = Path(rel).with_suffix(".pdf").as_posix()
                    nuevo = f"{URL_SHAREPOINT}{ruta_relativa}{fragmento}"
                    cambios.append((enlace, nuevo, "HTML->PDF (relativo)"))
                    return f'href={comilla}{nuevo}{comilla}'
                except Exception:
                    # no est√° dentro de CARPETA_RAIZ -> no modificar (evitamos hacer supuestos)
                    return match.group(0)
            except Exception:
                return match.group(0)

        # ----- Caso: recursos (docx/pdf/xlsx/...) -----
        elif extension in [".docx", ".pdf", ".xlsx", ".pptx", ".doc", ".xls", ".xlsm"]:
            m = re.search(r'calidad2021/formatos2021/', ruta_sin_fragmento, flags=re.IGNORECASE)
            if m:
                suffix = ruta_sin_fragmento[m.end():]
                # preservar subcarpetas despu√©s de Formatos2021 tal cual vienen
                nuevo = f"{URL_SHAREPOINT}{CARPETA_DE_RECURSOS}/{suffix}{fragmento}"
                cambios.append((enlace, nuevo, extension.upper().strip(".")))
                return f'href={comilla}{nuevo}{comilla}'
            return match.group(0)

        # Caso default: no tocar
        return match.group(0)

    # regex: aceptar opcional #fragment (NOTA: escapamos el '#' porque usamos re.VERBOSE)
    patron = r'''
        href=
        (["\'])
        ([^"\']+\.(?:htm[l]?|docx|pdf|xlsx|pptx|doc|xls|xlsm)(?:\#[^"']+)?)
        \1
    '''

    # IMPORTANTE: usamos re.VERBOSE, por eso escapamos '#' dentro del (?:\#[^"']+)? arriba.
    nuevo_contenido = re.sub(patron, reemplazar_enlace, contenido, flags=re.IGNORECASE | re.VERBOSE)
    return nuevo_contenido, cambios


def procesar_html(html_path):
    """Lee un HTML y convierte enlaces."""
    encoding_detectado = 'utf-8'
    try:
        with open(html_path, 'r', encoding='utf-8') as f:
            contenido = f.read()
    except UnicodeDecodeError:
        encoding_detectado = 'latin-1'
        with open(html_path, 'r', encoding='latin-1') as f:
            contenido = f.read()

    contenido_modificado, cambios = convertir_enlaces(contenido, html_path)
    return contenido_modificado, encoding_detectado, cambios


def copiar_estructura(html_path, output_dir):
    """Copia carpeta de recursos asociada (_archivos)."""
    html_name = html_path.stem
    carpeta_archivos = html_path.parent / f"{html_name}_archivos"
    if carpeta_archivos.exists():
        dest_dir = output_dir / f"{html_name}_archivos"
        shutil.copytree(carpeta_archivos, dest_dir, dirs_exist_ok=True)


def registrar_cambios(archivo_html, cambios):
    """Escribe cambios en el CSV log (sin fecha)."""
    existe = LOG_CSV.exists()
    with open(LOG_CSV, 'a', newline='', encoding='utf-8') as csvfile:
        writer = csv.writer(csvfile)
        if not existe:
            writer.writerow(["Archivo HTML", "Tipo", "Enlace original", "Enlace nuevo"])
        for original, nuevo, tipo in cambios:
            writer.writerow([archivo_html, tipo, original, nuevo])


# ================== PROCESO PRINCIPAL ==================
print("Iniciando conversi√≥n en carpeta ra√≠z:", CARPETA_RAIZ)
procesados = set()
total_modificados = 0

for html_file in CARPETA_RAIZ.rglob("*.[hH][tT][mM]*"):
    # evitar procesar archivos que est√©n dentro de carpetas *_archivos
    if html_file.is_file() and '_archivos' not in str(html_file.parent).lower() and html_file not in procesados:
        print(f"\n‚óè Procesando: {html_file.relative_to(CARPETA_RAIZ)}")
        procesados.add(html_file)

        cambios = []
        try:
            contenido, encoding_original, cambios = procesar_html(html_file)

            # Guardar el HTML modificado (sobrescribe)
            html_file.write_text(contenido, encoding=encoding_original)

            # Copiar carpeta de recursos asociada (si existe)
            copiar_estructura(html_file, html_file.parent)

            if cambios:
                registrar_cambios(str(html_file.relative_to(CARPETA_RAIZ)), cambios)
                num = len(cambios)
                total_modificados += num
                print(f"   ‚úÖ {num} enlace(s) modificado(s)")
            else:
                print("   ‚ö†Ô∏è No se encontraron enlaces relevantes")

        except Exception as e:
            print(f"   ‚ùå Error en {html_file.name}: {str(e)}")
            # si hubo cambios previos en este archivo, registrarlos igual
            if cambios:
                registrar_cambios(str(html_file.relative_to(CARPETA_RAIZ)), cambios)
                print(f"   ‚ö†Ô∏è {len(cambios)} enlace(s) registrados en log pese al error")

print("\n‚úî Proceso completado.")
print(f"üìë Log de cambios en: {LOG_CSV}")
print(f"üîÅ Enlaces totales modificados: {total_modificados}")
