import re
from pathlib import Path
import shutil
import os
import csv

# ================== CONFIGURACI√ìN ==================
CARPETA_RAIZ = Path(r"C:\Users\45056372\Desktop\prueba its\calidad2025")
CARPETA_DE_RECURSOS = "Formatos2021"
URL_SHAREPOINT = "https://teams.global.hsbc/sites/labpspyas-2019/CALIDAD20251/"
LOG_CSV = CARPETA_RAIZ.parent / "log_cambios.csv"


# ================== FUNCIONES ==================
def convertir_enlaces(contenido, ruta_html):
    """
    Convierte enlaces dentro de un HTML.
    """
    cambios = []

    def reemplazar_enlace(match):
        comilla = match.group(1)
        enlace = match.group(2)
        enlace_norm = enlace.replace("\\", "/")

        if "#" in enlace_norm:
            ruta_sin_fragmento, _ = enlace_norm.split("#", 1)
        else:
            ruta_sin_fragmento = enlace_norm

        nombre_base, extension = os.path.splitext(os.path.basename(ruta_sin_fragmento))
        extension = extension.lower()

        if extension in [".htm", ".html"]:
            m = re.search(r'calidad2021/', ruta_sin_fragmento, flags=re.IGNORECASE)
            if m:
                suffix = ruta_sin_fragmento[m.end():]
                ruta_relativa = Path(suffix).with_suffix(".pdf").as_posix()
                nuevo = f"{URL_SHAREPOINT}{ruta_relativa}"
                cambios.append((enlace, nuevo, "HTML->PDF"))
                return f'href={comilla}{nuevo}{comilla}'

            if ruta_sin_fragmento.startswith("/"):
                ruta_relativa = Path(ruta_sin_fragmento.lstrip("/")).with_suffix(".pdf").as_posix()
                nuevo = f"{URL_SHAREPOINT}{ruta_relativa}"
                cambios.append((enlace, nuevo, "HTML->PDF (raiz)"))
                return f'href={comilla}{nuevo}{comilla}'

            try:
                posible = (ruta_html.parent / ruta_sin_fragmento).resolve()
                try:
                    rel = posible.relative_to(CARPETA_RAIZ)
                    ruta_relativa = Path(rel).with_suffix(".pdf").as_posix()
                    nuevo = f"{URL_SHAREPOINT}{ruta_relativa}"
                    cambios.append((enlace, nuevo, "HTML->PDF (relativo)"))
                    return f'href={comilla}{nuevo}{comilla}'
                except Exception:
                    return match.group(0)
            except Exception:
                return match.group(0)

        elif extension in [".docx", ".pdf", ".xlsx", ".pptx", ".doc", ".xls", ".xlsm"]:
            m = re.search(r'calidad2021/formatos2021/', ruta_sin_fragmento, flags=re.IGNORECASE)
            if m:
                suffix = ruta_sin_fragmento[m.end():]
                nuevo = f"{URL_SHAREPOINT}{CARPETA_DE_RECURSOS}/{suffix}"
                cambios.append((enlace, nuevo, extension.upper().strip(".")))
                return f'href={comilla}{nuevo}{comilla}'
            return match.group(0)

        return match.group(0)

    patron = r'''
        href=
        (["\'])
        ([^"\']+\.(?:htm[l]?|docx|pdf|xlsx|pptx|doc|xls|xlsm)(?:\#[^"']+)?)
        \1
    '''
    nuevo_contenido = re.sub(patron, reemplazar_enlace, contenido, flags=re.IGNORECASE | re.VERBOSE)
    return nuevo_contenido, cambios


def leer_archivo_seguro(ruta_archivo):
    """Lee un archivo de manera segura con m√∫ltiples codificaciones."""
    codificaciones = ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']
    
    for encoding in codificaciones:
        try:
            with open(ruta_archivo, 'r', encoding=encoding) as f:
                contenido = f.read()
            print(f"   üìñ Le√≠do con encoding: {encoding} ({len(contenido)} caracteres)")
            return contenido, encoding, True
        except UnicodeDecodeError:
            continue
        except Exception as e:
            print(f"   ‚ùå Error leyendo con {encoding}: {e}")
            continue
    
    # √öltimo intento: lectura binaria
    try:
        with open(ruta_archivo, 'rb') as f:
            contenido_bytes = f.read()
        # Intentar decodificar como UTF-8 con reemplazo de errores
        contenido = contenido_bytes.decode('utf-8', errors='replace')
        print(f"   üìñ Le√≠do en modo binario y decodificado ({len(contenido)} caracteres)")
        return contenido, 'utf-8', True
    except Exception as e:
        print(f"   ‚ùå Error cr√≠tico leyendo archivo: {e}")
        return "", 'utf-8', False


def esta_en_carpeta_archivos(ruta_archivo):
    """Verifica si el archivo est√° dentro de una carpeta que termine con '_archivos'"""
    for parte in ruta_archivo.parts:
        if parte.endswith('_archivos'):
            return True
    return False


def copiar_estructura(html_path, output_dir):
    """Copia carpeta de recursos asociada (_archivos)."""
    html_name = html_path.stem
    carpeta_archivos = html_path.parent / f"{html_name}_archivos"
    if carpeta_archivos.exists():
        dest_dir = output_dir / f"{html_name}_archivos"
        shutil.copytree(carpeta_archivos, dest_dir, dirs_exist_ok=True)
        print(f"   üìÅ Carpeta de recursos copiada: {carpeta_archivos.name}")


def registrar_cambios(archivo_html, cambios):
    """Escribe cambios en el CSV log."""
    existe = LOG_CSV.exists()
    with open(LOG_CSV, 'a', newline='', encoding='utf-8') as csvfile:
        writer = csv.writer(csvfile)
        if not existe:
            writer.writerow(["Archivo HTML", "Tipo", "Enlace original", "Enlace nuevo"])
        for original, nuevo, tipo in cambios:
            writer.writerow([archivo_html, tipo, original, nuevo])


def hacer_backup(archivo_original):
    """Crea un backup del archivo original."""
    backup_path = archivo_original.with_suffix(archivo_original.suffix + '.backup')
    try:
        shutil.copy2(archivo_original, backup_path)
        print(f"   üíæ Backup creado: {backup_path.name}")
        return True
    except Exception as e:
        print(f"   ‚ö†Ô∏è No se pudo crear backup: {e}")
        return False


# ================== PROCESO PRINCIPAL ==================
print("Iniciando conversi√≥n en carpeta ra√≠z:", CARPETA_RAIZ)
procesados = set()
total_modificados = 0
archivos_con_errores = 0

for html_file in CARPETA_RAIZ.rglob("*.[hH][tT][mM]*"):
    if html_file.is_file():
        # Ignorar archivos en carpetas _archivos
        if esta_en_carpeta_archivos(html_file):
            print(f"‚è≠Ô∏è  IGNORADO (carpeta _archivos): {html_file.relative_to(CARPETA_RAIZ)}")
            continue

        if html_file not in procesados:
            print(f"\n‚óè Procesando: {html_file.relative_to(CARPETA_RAIZ)}")
            print(f"   üìä Tama√±o original: {html_file.stat().st_size} bytes")
            procesados.add(html_file)

            cambios = []
            try:
                # 1. HACER BACKUP primero
                backup_ok = hacer_backup(html_file)
                
                # 2. LEER archivo de manera segura
                contenido, encoding, exito_lectura = leer_archivo_seguro(html_file)
                
                if not exito_lectura or len(contenido) == 0:
                    print(f"   ‚ùå No se pudo leer el archivo o est√° vac√≠o")
                    archivos_con_errores += 1
                    continue
                
                # 3. VERIFICAR que el contenido no est√© vac√≠o
                if len(contenido.strip()) == 0:
                    print(f"   ‚ö†Ô∏è Archivo vac√≠o, saltando...")
                    continue
                
                # 4. PROCESAR enlaces
                contenido_modificado, cambios = convertir_enlaces(contenido, html_file)
                
                # 5. VERIFICAR que el contenido modificado no est√© vac√≠o
                if len(contenido_modificado.strip()) == 0:
                    print(f"   ‚ùå El contenido procesado est√° vac√≠o! Restaurando desde backup...")
                    if backup_ok:
                        backup_path = html_file.with_suffix(html_file.suffix + '.backup')
                        shutil.copy2(backup_path, html_file)
                        print(f"   üîÑ Archivo restaurado desde backup")
                    archivos_con_errores += 1
                    continue
                
                # 6. ESCRIBIR solo si hay cambios y el contenido es v√°lido
                if cambios:
                    html_file.write_text(contenido_modificado, encoding=encoding)
                    registrar_cambios(str(html_file.relative_to(CARPETA_RAIZ)), cambios)
                    num = len(cambios)
                    total_modificados += num
                    
                    # Verificar que el archivo no quede vac√≠o
                    tama√±o_final = html_file.stat().st_size
                    print(f"   ‚úÖ {num} enlace(s) modificado(s)")
                    print(f"   üìä Tama√±o final: {tama√±o_final} bytes")
                    
                    if tama√±o_final == 0:
                        print(f"   ‚ùå ARCHIVO QUED√ì VAC√çO! Restaurando...")
                        if backup_ok:
                            backup_path = html_file.with_suffix(html_file.suffix + '.backup')
                            shutil.copy2(backup_path, html_file)
                else:
                    print("   ‚ö†Ô∏è No se encontraron enlaces relevantes - archivo sin cambios")
                
                # 7. COPIAR recursos
                copiar_estructura(html_file, html_file.parent)

            except Exception as e:
                print(f"   ‚ùå Error procesando {html_file.name}: {str(e)}")
                archivos_con_errores += 1
                if cambios:
                    registrar_cambios(str(html_file.relative_to(CARPETA_RAIZ)), cambios)

print("\n‚úî Proceso completado.")
print(f"üìë Log de cambios en: {LOG_CSV}")
print(f"üîÅ Enlaces totales modificados: {total_modificados}")
print(f"‚ùå Archivos con errores: {archivos_con_errores}")
print(f"üìä Archivos procesados exitosamente: {len(procesados) - archivos_con_errores}")
