import os
import re
import csv
from pathlib import Path

# ðŸ”¹ ConfiguraciÃ³n
CARPETA_RAIZ = Path("../calidad2025")   # Carpeta raÃ­z que contiene todos los instructivos
URL_SHAREPOINT = "https://teams.global.hsbc/sites/labpspyas-2019/CALIDAD20251"
CARPETA_RECURSOS = "Formatos2021"

# ðŸ”¹ Logs
LOG_CSV = CARPETA_RAIZ / "../log_cambios.csv"
LOG_PRINT = CARPETA_RAIZ / "../log_prints.txt"

# Extensiones de office/pdf que se quieren modificar SOLO si contienen "calidad2021/formato2021"
EXT_RECURSOS = (".docx", ".pdf", ".xlsx", ".pptx", ".doc", ".xls", ".xlsm")


# -------------------------------
# Utilidad: escribir en log_print ademÃ¡s de consola
def log_print(msg: str):
    print(msg)
    with open(LOG_PRINT, "a", encoding="utf-8") as logf:
        logf.write(msg + "\n")


# -------------------------------
# Registrar cambios en log CSV
def registrar_cambio(archivo_html, tipo, enlace_original, enlace_nuevo):
    try:
        with open(LOG_CSV, "a", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow([archivo_html, tipo, enlace_original, enlace_nuevo])
    except Exception as e:
        log_print(f"[ERROR] No se pudo registrar cambio en {archivo_html}: {e}")


# -------------------------------
# ConversiÃ³n de enlaces dentro de un archivo
def convertir_enlaces(contenido: str, archivo_html: Path) -> str:
    def reemplazo(match):
        enlace = match.group(1)
        nuevo_enlace = enlace  # por defecto no cambia

        # ðŸ”¹ Caso 1: Enlaces a otros instructivos .htm / .html
        if enlace.lower().endswith((".htm", ".html")):
            ruta_relativa = os.path.splitext(enlace)[0] + ".pdf"
            nuevo_enlace = f"{URL_SHAREPOINT}/{archivo_html.parent.relative_to(CARPETA_RAIZ)}/{Path(ruta_relativa).name}"
            registrar_cambio(archivo_html, "htm->pdf", enlace, nuevo_enlace)
            log_print(f"[HTM->PDF] {archivo_html} : {enlace} -> {nuevo_enlace}")

        # ðŸ”¹ Caso 2: Archivos de recursos (solo si contienen calidad2021/formato2021)
        elif enlace.lower().endswith(EXT_RECURSOS) and "calidad2021" in enlace.lower():
            # quitar desde "calidad2021/formato2021"
            partes = re.split(r"calidad2021[/\\]formato2021[/\\]", enlace, flags=re.IGNORECASE)
            if len(partes) > 1:
                ruta_relativa = partes[1]
                nuevo_enlace = f"{URL_SHAREPOINT}/{CARPETA_RECURSOS}/{ruta_relativa}"
                registrar_cambio(archivo_html, "recurso", enlace, nuevo_enlace)
                log_print(f"[RECURSO] {archivo_html} : {enlace} -> {nuevo_enlace}")

        return match.group(0).replace(enlace, nuevo_enlace)

    patron = r'href="([^"]+)"'
    return re.sub(patron, reemplazo, contenido, flags=re.IGNORECASE)


# -------------------------------
# Procesar archivo HTML individual
def procesar_html(archivo_html: Path, procesados: set):
    if archivo_html in procesados:
        log_print(f"[SKIP] Ya procesado {archivo_html}")
        return

    # Ignorar carpetas *_archivos
    if archivo_html.stem.endswith("_archivos"):
        log_print(f"[IGNORADO] Carpeta de recursos {archivo_html}")
        return

    try:
        with open(archivo_html, "r", encoding="utf-8", errors="ignore") as f:
            contenido = f.read()

        nuevo_contenido = convertir_enlaces(contenido, archivo_html)

        with open(archivo_html, "w", encoding="utf-8", errors="ignore") as f:
            f.write(nuevo_contenido)

        log_print(f"[OK] Procesado {archivo_html}")
        procesados.add(archivo_html)

    except Exception as e:
        log_print(f"[ERROR] Procesando {archivo_html}: {e}")


# -------------------------------
# Recorrer todas las carpetas y procesar .htm/.html
def recorrer_y_procesar():
    procesados = set()

    # Inicializar logs
    with open(LOG_CSV, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["archivo_html", "tipo_archivo", "enlace_original", "enlace_nuevo"])
    with open(LOG_PRINT, "w", encoding="utf-8") as f:
        f.write("LOG DE EJECUCIÃ“N\n\n")

    for archivo in CARPETA_RAIZ.rglob("*.htm*"):
        # Ignorar carpetas *_archivos
        if archivo.is_file() and not archivo.stem.endswith("_archivos"):
            procesar_html(archivo, procesados)


# -------------------------------
if __name__ == "__main__":
    recorrer_y_procesar()
