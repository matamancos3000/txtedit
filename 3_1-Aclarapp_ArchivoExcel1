import pandas as pd
import logging
from pathlib import Path
import re
from datetime import datetime
import numpy as np

# =========================
# LOGGING
# =========================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# =========================
# CONFIGURACI√ìN
# =========================
BASE_PATH = Path("c:/Copia-reporte-Aclarabot")

# Buscar archivo CSV filtrado
CSV_PATTERN = "Acumulado_Filtrado_*.csv"
ARCHIVO_CSV = None
for archivo in BASE_PATH.glob(CSV_PATTERN):
    ARCHIVO_CSV = archivo
    break

if ARCHIVO_CSV is None:
    logger.error(f"No se encontr√≥ archivo {CSV_PATTERN} en {BASE_PATH}")
    exit(1)

# Crear carpeta para archivos Excel
EXCEL_FOLDER = BASE_PATH / "archivos_Excel"
EXCEL_FOLDER.mkdir(exist_ok=True)

# Nombre din√°mico del archivo Excel (en espa√±ol)
meses_es = {
    1: "Enero", 2: "Febrero", 3: "Marzo", 4: "Abril",
    5: "Mayo", 6: "Junio", 7: "Julio", 8: "Agosto",
    9: "Septiembre", 10: "Octubre", 11: "Noviembre", 12: "Diciembre"
}
fecha_hoy = datetime.now()
NOMBRE_EXCEL = f"Reporte_Aclarapp_{fecha_hoy.day}-{meses_es[fecha_hoy.month]}.xlsx"
RUTA_EXCEL = EXCEL_FOLDER / NOMBRE_EXCEL

# =========================
# FUNCIONES
# =========================
def limpiar_formato_fecha_especial(valor):
    """
    Limpia formato especial: dd/MM/yyyy hh:mm:ss p. m. (con espacio entre p. y m.)
    y a. m.
    """
    if pd.isna(valor):
        return valor
    
    valor_str = str(valor).strip()
    
    if not valor_str or valor_str.lower() in ['nan', 'nat', 'null', 'none', '']:
        return valor
    
    # Corregir el espacio entre p. y m. / a. y m.
    valor_str = re.sub(r'p\.\s*m\.', 'PM', valor_str, flags=re.IGNORECASE)
    valor_str = re.sub(r'a\.\s*m\.', 'AM', valor_str, flags=re.IGNORECASE)
    
    # Tambi√©n manejar casos con puntos en el tiempo
    valor_str = re.sub(r'(\d{1,2})\.(\d{1,2})\.(\d{1,2})', r'\1:\2:\3', valor_str)
    
    return valor_str.strip()

def parsear_fecha(fecha_str):
    """Convierte string de fecha a datetime"""
    if pd.isna(fecha_str):
        return pd.NaT
    
    # Limpiar formato especial
    fecha_limpia = limpiar_formato_fecha_especial(fecha_str)
    
    # Intentar parsear con diferentes formatos
    try:
        # Formato con AM/PM
        return pd.to_datetime(fecha_limpia, format="%d/%m/%Y %I:%M:%S %p", errors='coerce')
    except:
        try:
            # Formato 24h
            return pd.to_datetime(fecha_limpia, format="%d/%m/%Y %H:%M:%S", errors='coerce')
        except:
            # Parseo autom√°tico
            return pd.to_datetime(fecha_limpia, dayfirst=True, errors='coerce')

def calcular_tiempo_minutos(fecha_inicio, fecha_fin):
    """Calcula diferencia en minutos entre dos fechas"""
    if pd.isna(fecha_inicio) or pd.isna(fecha_fin):
        return np.nan
    
    try:
        diferencia = fecha_fin - fecha_inicio
        # Si la diferencia es negativa, retornar NaN
        if diferencia.total_seconds() < 0:
            return np.nan
        return diferencia.total_seconds() / 60  # Convertir a minutos
    except:
        return np.nan

# =========================
# MAIN
# =========================
def main():
    logger.info("üöÄ Iniciando generaci√≥n de reporte Excel")
    logger.info(f"üìÇ Archivo fuente: {ARCHIVO_CSV.name}")
    logger.info(f"üìä Archivo destino: {NOMBRE_EXCEL}")
    
    # =========================
    # 1. CARGAR DATOS
    # =========================
    logger.info("üì• Cargando datos del CSV...")
    
    try:
        df = pd.read_csv(ARCHIVO_CSV, dtype=str, encoding='utf-8-sig')
    except Exception as e:
        logger.error(f"Error al cargar CSV: {e}")
        return
    
    logger.info(f"  Filas originales: {len(df)}")
    logger.info(f"  Columnas encontradas: {len(df.columns)}")
    
    # Mostrar todas las columnas para debugging
    logger.debug(f"  Columnas disponibles: {list(df.columns)}")
    
    # =========================
    # 2. FILTRAR POR STATUS
    # =========================
    logger.info("üîç Filtrando datos (eliminando Estatus = False)...")
    
    # Buscar columna Estatus (puede tener diferentes nombres)
    columna_estatus = None
    posibles_nombres = ['Estatus', 'estatus', 'ESTATUS', 'Status', 'status']
    
    for nombre in posibles_nombres:
        if nombre in df.columns:
            columna_estatus = nombre
            break
    
    if columna_estatus:
        filas_antes = len(df)
        df = df[df[columna_estatus] != 'False']
        filas_filtradas = filas_antes - len(df)
        logger.info(f"  Filas eliminadas: {filas_filtradas}")
        logger.info(f"  Filas despu√©s de filtrar: {len(df)}")
    else:
        logger.warning("  Columna 'Estatus' no encontrada, continuando sin filtrar")
    
    # =========================
    # 3. VERIFICAR Y SELECCIONAR COLUMNAS NECESARIAS
    # =========================
    logger.info("üìã Verificando columnas necesarias...")
    
    # Mapeo de nombres posibles para cada columna
    columnas_mapeo = {
        'Fecha': ['Fecha', 'fecha', 'FECHA', 'Date', 'date'],
        'Tipo de tarjeta': ['Tipo de tarjeta', 'Tipo Tarjeta', 'Tipo tarjeta', 'tipo de tarjeta'],
        'Tipo de aclaracion': ['Tipo de aclaracion', 'Tipo Aclaracion', 'Tipo aclaracion', 'tipo de aclaracion'],
        'Detalles de aclaracion': ['Detalles de aclaracion', 'Detalles Aclaracion', 'detalles de aclaracion'],
        'Cargos': ['Cargos', 'cargos', 'CARGO', 'Cargo', 'cargo'],
        'RobotID': ['RobotID', 'Robot Id', 'robotid', 'ROBOTID'],
        'AclaracionID': ['AclaracionID', 'Aclaracion Id', 'aclaracionid'],
        'Estatus': ['Estatus', 'estatus', 'ESTATUS', 'Status', 'status'],
        'Registro': ['Registro', 'registro', 'REGISTRO', 'Numero de registro'],
        'Folio': ['Folio', 'folio', 'FOLIO', 'Folio SCC'],
        'CIS_1': ['CIS_1', 'CIS', 'cis_1', 'cis'],
        'Fecha Creaci√≥n': ['Fecha Creaci√≥n', 'Fecha Creacion', 'Fecha creaci√≥n', 'fecha creaci√≥n'],
        'Fecha Enviado': ['Fecha Enviado', 'Fecha enviado', 'fecha enviado'],
        'Fecha Asignacion': ['Fecha Asignacion', 'Fecha Asignaci√≥n', 'fecha asignacion'],
        'Fecha Atendido': ['Fecha Atendido', 'Fecha atendido', 'fecha atendido'],
        'NOMBRE': ['NOMBRE', 'Nombre', 'nombre', 'NOMBRE AGENTE', 'Nombre Agente'],
        'Supervisor': ['Supervisor', 'supervisor', 'SUPERVISOR'],
        'Site': ['Site', 'site', 'SITE'],
        'Skill': ['Skill', 'skill', 'SKILL']
    }
    
    # Encontrar los nombres reales de las columnas
    columnas_reales = {}
    for col_standard, posibles_nombres in columnas_mapeo.items():
        for nombre in posibles_nombres:
            if nombre in df.columns:
                columnas_reales[col_standard] = nombre
                break
    
    # Mostrar qu√© columnas se encontraron
    logger.info("  Columnas encontradas:")
    for col_standard, col_real in columnas_reales.items():
        logger.info(f"    {col_standard} -> {col_real}")
    
    # Columnas no encontradas
    columnas_no_encontradas = [col for col in columnas_mapeo.keys() if col not in columnas_reales]
    if columnas_no_encontradas:
        logger.warning(f"  Columnas no encontradas: {columnas_no_encontradas}")
    
    # Renombrar columnas a nombres est√°ndar
    for col_standard, col_real in columnas_reales.items():
        if col_real != col_standard:
            df.rename(columns={col_real: col_standard}, inplace=True)
    
    # =========================
    # 4. PROCESAR FECHAS
    # =========================
    logger.info("‚è∞ Procesando fechas...")
    
    columnas_fecha = ['Fecha', 'Fecha Creaci√≥n', 'Fecha Enviado', 'Fecha Asignacion', 'Fecha Atendido']
    
    for col in columnas_fecha:
        if col in df.columns:
            logger.info(f"  Procesando {col}...")
            # Mostrar ejemplos antes de procesar
            ejemplos = df[col].dropna().head(3).tolist()
            for i, ejemplo in enumerate(ejemplos):
                logger.debug(f"    Ejemplo {i} original: '{ejemplo}'")
            
            df[col] = df[col].apply(parsear_fecha)
            
            # Verificar conversi√≥n
            nulos = df[col].isna().sum()
            total = len(df)
            logger.info(f"    Convertidas: {total - nulos}/{total} ({(total - nulos)/total*100:.1f}%)")
            
            if nulos > 0 and nulos < 5:
                ejemplos_no_convertidos = df.loc[df[col].isna(), col].head(3).tolist()
                logger.warning(f"    Ejemplos no convertidos: {ejemplos_no_convertidos}")
    
    # =========================
    # 5. CALCULAR TIEMPOS
    # =========================
    logger.info("‚è±Ô∏è Calculando tiempos...")
    
    # Tiempo de captura agente (Fecha Enviado - Fecha Creaci√≥n) en minutos
    if 'Fecha Enviado' in df.columns and 'Fecha Creaci√≥n' in df.columns:
        df['Tiempo de captura agente'] = df.apply(
            lambda row: calcular_tiempo_minutos(row['Fecha Creaci√≥n'], row['Fecha Enviado']), axis=1
        )
        logger.info(f"  Tiempo de captura agente calculado")
        
        # Convertir a segundos
        df['Tiempo de captura agente segundos'] = df['Tiempo de captura agente'] * 60
        logger.info(f"  Tiempo de captura agente segundos calculado")
        
        # Estad√≠sticas
        tiempo_prom_captura = df['Tiempo de captura agente'].mean()
        logger.info(f"    Tiempo promedio: {tiempo_prom_captura:.2f} minutos")
    
    # Tiempo de alta robot (Fecha - Fecha Asignacion) en minutos
    if 'Fecha' in df.columns and 'Fecha Asignacion' in df.columns:
        df['Tiempo de alta robot'] = df.apply(
            lambda row: calcular_tiempo_minutos(row['Fecha Asignacion'], row['Fecha']), axis=1
        )
        logger.info(f"  Tiempo de alta robot calculado")
        
        # Convertir a segundos
        df['Tiempo de alta robot segundos'] = df['Tiempo de alta robot'] * 60
        logger.info(f"  Tiempo de alta robot segundos calculado")
        
        # Estad√≠sticas
        tiempo_prom_alta = df['Tiempo de alta robot'].mean()
        logger.info(f"    Tiempo promedio: {tiempo_prom_alta:.2f} minutos")
    
    # Contar n√∫mero de cargos (suponiendo que es num√©rico)
    if 'Cargos' in df.columns:
        try:
            df['Numero de cargos'] = pd.to_numeric(df['Cargos'], errors='coerce').fillna(0)
            logger.info(f"  N√∫mero de cargos calculado")
        except Exception as e:
            df['Numero de cargos'] = 0
            logger.warning(f"  Error calculando n√∫mero de cargos: {e}")
    
    # =========================
    # 6. RENOMBRAR COLUMNAS Y VALORES
    # =========================
    logger.info("üè∑Ô∏è Renombrando columnas y valores...")
    
    if 'NOMBRE' in df.columns:
        df = df.rename(columns={'NOMBRE': 'Nombre Agente'})
        logger.info("  'NOMBRE' renombrado a 'Nombre Agente'")
    
    if 'Estatus' in df.columns:
        filas_antes = df['Estatus'].eq('True').sum()
        df['Estatus'] = df['Estatus'].replace({'True': 'exitoso'})
        filas_despues = df['Estatus'].eq('exitoso').sum()
        logger.info(f"  'Estatus' actualizado: {filas_antes} 'True' -> {filas_despues} 'exitoso'")
    
    # =========================
    # 7. REORDENAR COLUMNAS FINALES
    # =========================
    logger.info("üìä Estructurando columnas finales...")
    
    columnas_finales = [
        'Fecha', 'Tipo de tarjeta', 'Tipo de aclaracion', 'Detalles de aclaracion',
        'Cargos', 'RobotID', 'AclaracionID', 'Estatus', 'Registro', 'Folio',
        'CIS_1', 'Fecha Creaci√≥n', 'Fecha Enviado', 'Fecha Asignacion', 'Fecha Atendido',
        'Tiempo de captura agente', 'Tiempo de alta robot',
        'Tiempo de captura agente segundos', 'Tiempo de alta robot segundos',
        'Numero de cargos', 'Nombre Agente', 'Supervisor', 'Site', 'Skill'
    ]
    
    # Solo mantener columnas que existen
    columnas_finales_existentes = [col for col in columnas_finales if col in df.columns]
    columnas_faltantes = [col for col in columnas_finales if col not in df.columns]
    
    if columnas_faltantes:
        logger.warning(f"  Columnas faltantes en el resultado: {columnas_faltantes}")
    
    df = df[columnas_finales_existentes]
    
    logger.info(f"  Columnas finales: {len(columnas_finales_existentes)}")
    for col in columnas_finales_existentes:
        no_nulos = df[col].notna().sum()
        logger.info(f"    {col}: {no_nulos}/{len(df)} no nulos")
    
    logger.info(f"  Filas finales: {len(df)}")
    
    # =========================
    # 8. ELIMINAR ARCHIVOS EXCEL ANTERIORES
    # =========================
    logger.info("üóëÔ∏è Limpiando archivos Excel anteriores...")
    
    # Eliminar archivos de d√≠as anteriores (mantener solo el de hoy)
    archivos_eliminados = 0
    for archivo_excel in EXCEL_FOLDER.glob("Reporte_Aclarapp_*.xlsx"):
        if archivo_excel.name != NOMBRE_EXCEL:
            try:
                archivo_excel.unlink()
                logger.info(f"  Eliminado: {archivo_excel.name}")
                archivos_eliminados += 1
            except Exception as e:
                logger.warning(f"  No se pudo eliminar {archivo_excel.name}: {e}")
    
    logger.info(f"  Total archivos eliminados: {archivos_eliminados}")
    
    # =========================
    # 9. CREAR ARCHIVO EXCEL
    # =========================
    logger.info(f"üíæ Creando archivo Excel: {RUTA_EXCEL}")
    
    try:
        # Crear Excel con pandas (usar√° openpyxl por defecto)
        with pd.ExcelWriter(RUTA_EXCEL, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='Reporte', index=False)
            
            # Ajustar ancho de columnas
            worksheet = writer.sheets['Reporte']
            for column in worksheet.columns:
                max_length = 0
                column_letter = column[0].column_letter
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = min(max_length + 2, 30)
                worksheet.column_dimensions[column_letter].width = adjusted_width
        
        logger.info("‚úÖ Reporte Excel generado exitosamente")
        logger.info(f"üìÑ Archivo: {RUTA_EXCEL}")
        logger.info(f"üìä Total registros en reporte: {len(df)}")
        
    except Exception as e:
        logger.error(f"‚ùå Error al crear Excel: {e}")
        # Intentar con formato m√°s simple
        try:
            df.to_excel(RUTA_EXCEL, index=False)
            logger.info("‚úÖ Reporte creado con formato b√°sico")
        except Exception as e2:
            logger.error(f"‚ùå Error cr√≠tico al crear Excel: {e2}")
            return
    
    # =========================
    # 10. RESUMEN FINAL
    # =========================
    logger.info("\n" + "="*60)
    logger.info("üìã RESUMEN FINAL DEL REPORTE")
    logger.info("="*60)
    
    logger.info(f"üìà TOTAL DE REGISTROS: {len(df)}")
    
    if 'Estatus' in df.columns:
        exitosos = df['Estatus'].eq('exitoso').sum()
        otros = len(df) - exitosos
        logger.info(f"üìä ESTATUS:")
        logger.info(f"  ‚Ä¢ Exitosos: {exitosos} ({exitosos/len(df)*100:.1f}%)")
        logger.info(f"  ‚Ä¢ Otros: {otros} ({otros/len(df)*100:.1f}%)")
    
    if 'Nombre Agente' in df.columns:
        agentes_unicos = df['Nombre Agente'].nunique()
        logger.info(f"üë• AGENTES: {agentes_unicos} √∫nicos")
    
    if 'Tiempo de captura agente' in df.columns:
        tiempo_prom_captura = df['Tiempo de captura agente'].mean()
        tiempo_max_captura = df['Tiempo de captura agente'].max()
        logger.info(f"‚è±Ô∏è TIEMPO CAPTURA AGENTE:")
        logger.info(f"  ‚Ä¢ Promedio: {tiempo_prom_captura:.2f} minutos")
        logger.info(f"  ‚Ä¢ M√°ximo: {tiempo_max_captura:.2f} minutos")
    
    if 'Tiempo de alta robot' in df.columns:
        tiempo_prom_alta = df['Tiempo de alta robot'].mean()
        tiempo_max_alta = df['Tiempo de alta robot'].max()
        logger.info(f"ü§ñ TIEMPO ALTA ROBOT:")
        logger.info(f"  ‚Ä¢ Promedio: {tiempo_prom_alta:.2f} minutos")
        logger.info(f"  ‚Ä¢ M√°ximo: {tiempo_max_alta:.2f} minutos")
    
    if 'Tipo de aclaracion' in df.columns:
        tipos_unicos = df['Tipo de aclaracion'].nunique()
        logger.info(f"üìù TIPOS DE ACLARACI√ìN: {tipos_unicos} diferentes")
    
    logger.info("="*60)
    logger.info(f"‚úÖ PROCESO COMPLETADO")
    logger.info(f"üìÅ Archivo guardado en: {RUTA_EXCEL}")

# =========================
# EJECUCI√ìN
# =========================
if __name__ == "__main__":
    main()
