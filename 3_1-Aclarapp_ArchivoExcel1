import pandas as pd
import logging
from pathlib import Path
from datetime import datetime, timedelta
import locale
import re
import numpy as np

# =========================
# LOGGING
# =========================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# =========================
# CONFIGURACI√ìN
# =========================
BASE_PATH = Path("c:/Copia-reporte-Aclarabot")
EXCEL_PATH = BASE_PATH / "archivos_Excel"
EXCEL_PATH.mkdir(exist_ok=True)

CSV_FILE = next(BASE_PATH.glob("Acumulado_filtrado_*.csv"))

# Locale espa√±ol (solo para nombre del archivo)
try:
    locale.setlocale(locale.LC_TIME, "Spanish_Spain")
except:
    try:
        locale.setlocale(locale.LC_TIME, "es_ES")
    except:
        logger.warning("‚ö†Ô∏è Locale espa√±ol no disponible")

HOY = datetime.now()
FECHA_TEXTO = HOY.strftime("%d-%B").capitalize()
OUTPUT_FILE = EXCEL_PATH / f"Reporte_Aclarapp_{FECHA_TEXTO}.xlsx"

# =========================
# COLUMNAS DE SALIDA
# =========================
COLUMNAS_SALIDA = [
    "Fecha",
    "Tipo de tarjeta",
    "Tipo de aclaracion",
    "Detalles de aclaracion",
    "Cargos",
    "RobotID",
    "AclaracionID",
    "Estatus",
    "Registro",
    "Folio",
    "CIS",
    "Fecha Creacion",
    "Fecha Enviado",
    "Fecha Asignacion",
    "Fecha Atendido",
    "Tiempo de captura agente",
    "Tiempo de alta robot",
    "Tiempo de captura agente segundos",
    "Tiempo de alta robot segundos",
    "Categoria tiempo agente",
    "Categoria tiempo Alta robot",
    "Numero de cargos",
    "Categoria de cargos",
    "Nombre Agente",
    "Supervisor",
    "Site",
    "Skill"
]

# =========================
# FUNCIONES AUXILIARES
# =========================
def convertir_columna_fecha(df, columna):
    """
    Convierte una columna de fecha de formato yyyy-MM-dd HH:mm:ss a datetime
    """
    if columna not in df.columns:
        logger.warning(f"‚ö†Ô∏è Columna '{columna}' no encontrada")
        return df
    
    logger.info(f"üîÑ Convirtiendo columna: {columna}")
    
    valores_antes = df[columna].notna().sum()
    
    if valores_antes == 0:
        logger.info("  ‚ö†Ô∏è No hay valores para convertir")
        return df
    
    try:
        # Intentar convertir del formato yyyy-MM-dd HH:mm:ss
        df[columna] = pd.to_datetime(
            df[columna],
            format='%Y-%m-%d %H:%M:%S',
            errors='coerce'
        )
        
        valores_despues = df[columna].notna().sum()
        logger.info(f"  Valores convertidos: {valores_despues}/{valores_antes}")
        
        if valores_despues < valores_antes:
            no_convertidos = valores_antes - valores_despues
            logger.warning(f"  ‚ö†Ô∏è {no_convertidos} valores no se pudieron convertir")
        
    except Exception as e:
        logger.error(f"‚ùå Error convirtiendo {columna}: {e}")
        df[columna] = pd.to_datetime(df[columna], errors='coerce')
    
    return df

def calcular_tiempo_en_minutos_segundos(segundos_totales):
    """
    Convierte segundos a formato mm:ss
    """
    if pd.isna(segundos_totales) or segundos_totales < 0:
        return None
    
    minutos = int(segundos_totales // 60)
    segundos = int(segundos_totales % 60)
    
    return f"{minutos:02d}:{segundos:02d}"

def categorizar_tiempo_agente(segundos):
    """
    Categoriza el tiempo de captura agente seg√∫n los intervalos especificados
    """
    if pd.isna(segundos) or segundos < 0:
        return None
    
    if segundos < 60:
        return "menos de 1 minuto"
    elif segundos <= 90:
        return "menos de 1m 30s"
    elif segundos <= 180:
        return "de 1m 30s a 3m"
    elif segundos <= 300:
        return "de 3m a 5m"
    elif segundos <= 600:
        return "de 5m a 10m"
    else:  # > 600
        return "mayor a 10 minutos"

def categorizar_tiempo_alta_robot(segundos):
    """
    Categoriza el tiempo de alta robot seg√∫n los intervalos especificados
    """
    if pd.isna(segundos) or segundos < 0:
        return None
    
    if segundos < 60:
        return "menos de 1m"
    elif segundos <= 90:
        return "de 1m a 1m 30s"
    elif segundos <= 180:
        return "de 1m 30s a 3m"
    elif segundos <= 300:
        return "de 3m a 5m"
    elif segundos <= 600:
        return "de 5m a 10m"
    elif segundos <= 900:
        return "de 10m a 15m"
    elif segundos <= 1200:
        return "de 15m a 20m"
    else:  # > 1200
        return "mayor a 20m"

def categorizar_numero_cargos(num_cargos):
    """
    Categoriza el n√∫mero de cargos seg√∫n los intervalos especificados
    """
    if pd.isna(num_cargos) or num_cargos <= 0:
        return None
    
    num_cargos_int = int(num_cargos)
    
    if num_cargos_int == 1:
        return "1 cargo"
    elif 2 <= num_cargos_int <= 5:
        return "2 a 5 cargos"
    elif 6 <= num_cargos_int <= 10:
        return "6 a 10 cargos"
    elif 11 <= num_cargos_int <= 20:
        return "11 a 20 cargos"
    elif 21 <= num_cargos_int <= 30:
        return "21 a 30 cargos"
    elif 31 <= num_cargos_int <= 40:
        return "31 a 40 cargos"
    elif 41 <= num_cargos_int <= 50:
        return "41 a 50 cargos"
    elif 51 <= num_cargos_int <= 60:
        return "51 a 60 cargos"
    elif 61 <= num_cargos_int <= 70:
        return "61 a 70 cargos"
    elif 71 <= num_cargos_int <= 80:
        return "71 a 80 cargos"
    elif 81 <= num_cargos_int <= 90:
        return "81 a 90 cargos"
    elif 91 <= num_cargos_int <= 100:
        return "91 a 100 cargos"
    else:  # > 100
        return "m√°s de 100 cargos"

def calcular_tiempos_agente_robot(df):
    """
    Calcula los tiempos de captura agente y alta robot
    """
    logger.info("\n‚è±Ô∏è CALCULANDO TIEMPOS...")
    
    # =========================
    # 1. TIEMPO DE CAPTURA AGENTE (Fecha Enviado - Fecha Creacion)
    # =========================
    logger.info("\nüîπ Tiempo de captura agente (Fecha Enviado - Fecha Creacion):")
    
    # Verificar columnas necesarias
    columnas_requeridas = ["Fecha Creacion", "Fecha Enviado"]
    for col in columnas_requeridas:
        if col not in df.columns:
            logger.error(f"‚ùå Columna '{col}' no encontrada para c√°lculo")
            return df
    
    # Calcular diferencia en segundos
    mask_fechas_validas = df["Fecha Creacion"].notna() & df["Fecha Enviado"].notna()
    total_filas_validas = mask_fechas_validas.sum()
    
    logger.info(f"  Filas con ambas fechas v√°lidas: {total_filas_validas}/{len(df)}")
    
    if total_filas_validas > 0:
        # Calcular diferencia en segundos
        df.loc[mask_fechas_validas, "Tiempo de captura agente segundos"] = (
            (df.loc[mask_fechas_validas, "Fecha Enviado"] - 
             df.loc[mask_fechas_validas, "Fecha Creacion"]).dt.total_seconds()
        )
        
        # Convertir a formato mm:ss
        df.loc[mask_fechas_validas, "Tiempo de captura agente"] = df.loc[
            mask_fechas_validas, "Tiempo de captura agente segundos"
        ].apply(calcular_tiempo_en_minutos_segundos)
        
        # Categorizar tiempo agente
        df.loc[mask_fechas_validas, "Categoria tiempo agente"] = df.loc[
            mask_fechas_validas, "Tiempo de captura agente segundos"
        ].apply(categorizar_tiempo_agente)
        
        # Estad√≠sticas
        segundos_no_nulos = df["Tiempo de captura agente segundos"].notna().sum()
        logger.info(f"  Tiempos calculados: {segundos_no_nulos}")
        
        if segundos_no_nulos > 0:
            # Mostrar distribuci√≥n de categor√≠as
            logger.info("  Distribuci√≥n de categor√≠as de tiempo agente:")
            categorias = df["Categoria tiempo agente"].value_counts()
            for categoria, count in categorias.items():
                if pd.notna(categoria):
                    logger.info(f"    {categoria}: {count}")
            
            # Mostrar un ejemplo
            idx_ejemplo = df[mask_fechas_validas].index[0]
            ejemplo = df.loc[idx_ejemplo]
            logger.info(f"  Ejemplo de c√°lculo:")
            logger.info(f"    Segundos: {ejemplo['Tiempo de captura agente segundos']:.0f}")
            logger.info(f"    Formato mm:ss: {ejemplo['Tiempo de captura agente']}")
            logger.info(f"    Categor√≠a: {ejemplo['Categoria tiempo agente']}")
        
        # Estad√≠sticas descriptivas
        if segundos_no_nulos > 0:
            min_seg = df["Tiempo de captura agente segundos"].min()
            max_seg = df["Tiempo de captura agente segundos"].max()
            mean_seg = df["Tiempo de captura agente segundos"].mean()
            
            logger.info(f"  Estad√≠sticas (segundos):")
            logger.info(f"    M√≠nimo: {min_seg:.0f}s")
            logger.info(f"    M√°ximo: {max_seg:.0f}s")
            logger.info(f"    Promedio: {mean_seg:.0f}s")
    else:
        logger.warning("  ‚ö†Ô∏è No hay filas con ambas fechas v√°lidas para calcular")
        df["Tiempo de captura agente"] = None
        df["Tiempo de captura agente segundos"] = None
        df["Categoria tiempo agente"] = None
    
    # =========================
    # 2. TIEMPO DE ALTA ROBOT (Fecha Atendido - Fecha Asignacion)
    # =========================
    logger.info("\nüîπ Tiempo de alta robot (Fecha Atendido - Fecha Asignacion):")
    
    # Verificar columnas necesarias
    columnas_requeridas = ["Fecha Asignacion", "Fecha Atendido"]
    for col in columnas_requeridas:
        if col not in df.columns:
            logger.error(f"‚ùå Columna '{col}' no encontrada para c√°lculo")
            return df
    
    # Calcular diferencia en segundos
    mask_fechas_validas = df["Fecha Asignacion"].notna() & df["Fecha Atendido"].notna()
    total_filas_validas = mask_fechas_validas.sum()
    
    logger.info(f"  Filas con ambas fechas v√°lidas: {total_filas_validas}/{len(df)}")
    
    if total_filas_validas > 0:
        # Calcular diferencia en segundos
        df.loc[mask_fechas_validas, "Tiempo de alta robot segundos"] = (
            (df.loc[mask_fechas_validas, "Fecha Atendido"] - 
             df.loc[mask_fechas_validas, "Fecha Asignacion"]).dt.total_seconds()
        )
        
        # Convertir a formato mm:ss
        df.loc[mask_fechas_validas, "Tiempo de alta robot"] = df.loc[
            mask_fechas_validas, "Tiempo de alta robot segundos"
        ].apply(calcular_tiempo_en_minutos_segundos)
        
        # Categorizar tiempo alta robot
        df.loc[mask_fechas_validas, "Categoria tiempo Alta robot"] = df.loc[
            mask_fechas_validas, "Tiempo de alta robot segundos"
        ].apply(categorizar_tiempo_alta_robot)
        
        # Estad√≠sticas
        segundos_no_nulos = df["Tiempo de alta robot segundos"].notna().sum()
        logger.info(f"  Tiempos calculados: {segundos_no_nulos}")
        
        if segundos_no_nulos > 0:
            # Mostrar distribuci√≥n de categor√≠as
            logger.info("  Distribuci√≥n de categor√≠as de tiempo alta robot:")
            categorias = df["Categoria tiempo Alta robot"].value_counts()
            for categoria, count in categorias.items():
                if pd.notna(categoria):
                    logger.info(f"    {categoria}: {count}")
            
            # Mostrar un ejemplo
            idx_ejemplo = df[mask_fechas_validas].index[0]
            ejemplo = df.loc[idx_ejemplo]
            logger.info(f"  Ejemplo de c√°lculo:")
            logger.info(f"    Segundos: {ejemplo['Tiempo de alta robot segundos']:.0f}")
            logger.info(f"    Formato mm:ss: {ejemplo['Tiempo de alta robot']}")
            logger.info(f"    Categor√≠a: {ejemplo['Categoria tiempo Alta robot']}")
        
        # Estad√≠sticas descriptivas
        if segundos_no_nulos > 0:
            min_seg = df["Tiempo de alta robot segundos"].min()
            max_seg = df["Tiempo de alta robot segundos"].max()
            mean_seg = df["Tiempo de alta robot segundos"].mean()
            
            logger.info(f"  Estad√≠sticas (segundos):")
            logger.info(f"    M√≠nimo: {min_seg:.0f}s")
            logger.info(f"    M√°ximo: {max_seg:.0f}s")
            logger.info(f"    Promedio: {mean_seg:.0f}s")
    else:
        logger.warning("  ‚ö†Ô∏è No hay filas con ambas fechas v√°lidas para calcular")
        df["Tiempo de alta robot"] = None
        df["Tiempo de alta robot segundos"] = None
        df["Categoria tiempo Alta robot"] = None
    
    return df

def calcular_categorias_cargos(df):
    """
    Calcula la categor√≠a de cargos basada en el n√∫mero de cargos
    """
    logger.info("\nüí∞ CALCULANDO CATEGOR√çAS DE CARGOS...")
    
    if "Numero de cargos" not in df.columns:
        logger.warning("‚ö†Ô∏è Columna 'Numero de cargos' no encontrada")
        df["Categoria de cargos"] = None
        return df
    
    # Calcular categor√≠as
    valores_no_nulos = df["Numero de cargos"].notna().sum()
    logger.info(f"  Filas con n√∫mero de cargos v√°lido: {valores_no_nulos}/{len(df)}")
    
    if valores_no_nulos > 0:
        # Aplicar categorizaci√≥n
        df["Categoria de cargos"] = df["Numero de cargos"].apply(categorizar_numero_cargos)
        
        # Mostrar distribuci√≥n
        logger.info("  Distribuci√≥n de categor√≠as de cargos:")
        categorias = df["Categoria de cargos"].value_counts().head(10)  # Mostrar top 10
        for categoria, count in categorias.items():
            if pd.notna(categoria):
                logger.info(f"    {categoria}: {count}")
        
        # Mostrar un ejemplo
        idx_ejemplo = df[df["Categoria de cargos"].notna()].index[0]
        ejemplo = df.loc[idx_ejemplo]
        logger.info(f"  Ejemplo:")
        logger.info(f"    N√∫mero de cargos: {ejemplo['Numero de cargos']}")
        logger.info(f"    Categor√≠a: {ejemplo['Categoria de cargos']}")
        
        # Estad√≠sticas
        total_categorias = df["Categoria de cargos"].notna().sum()
        logger.info(f"  Total categorizados: {total_categorias}")
    else:
        logger.warning("  ‚ö†Ô∏è No hay valores v√°lidos para categorizar")
        df["Categoria de cargos"] = None
    
    return df

# =========================
# MAIN
# =========================
def main():
    logger.info("üöÄ Generando Reporte Excel Aclarapp con c√°lculos de tiempo y categor√≠as")

    # =========================
    # CARGA CSV
    # =========================
    df = pd.read_csv(CSV_FILE, dtype=str, encoding="utf-8-sig")
    logger.info(f"‚úì CSV cargado: {CSV_FILE.name} ({len(df)} filas)")

    # =========================
    # VERIFICAR COLUMNAS DE FECHA EXISTENTES
    # =========================
    logger.info("\nüîç VERIFICANDO COLUMNAS DE FECHA...")
    
    columnas_fecha = [
        "Fecha",
        "Fecha Creacion",  # Nota: en el CSV original es "Fecha Creaci√≥n" con acento
        "Fecha Enviado",
        "Fecha Asignacion",
        "Fecha Atendido"
    ]
    
    # Verificar qu√© columnas realmente existen
    columnas_existentes = []
    for col in columnas_fecha:
        if col in df.columns:
            columnas_existentes.append(col)
            logger.info(f"  ‚úì {col}: encontrada")
        else:
            # Buscar variantes (con acentos, etc.)
            posibles_variantes = {
                "Fecha Creacion": ["Fecha Creaci√≥n", "Fecha_Creacion", "FechaCreacion"],
                "Fecha Enviado": ["Fecha_Enviado", "FechaEnviado"],
                "Fecha Asignacion": ["Fecha_Asignacion", "FechaAsignacion", "Fecha Asignaci√≥n"],
                "Fecha Atendido": ["Fecha_Atendido", "FechaAtendido"]
            }
            
            encontrada = False
            if col in posibles_variantes:
                for variante in posibles_variantes[col]:
                    if variante in df.columns:
                        # Renombrar para uniformidad
                        df = df.rename(columns={variante: col})
                        columnas_existentes.append(col)
                        logger.info(f"  ‚úì {variante} ‚Üí renombrada a {col}")
                        encontrada = True
                        break
            
            if not encontrada:
                logger.warning(f"  ‚ö†Ô∏è {col}: NO encontrada")
    
    logger.info(f"Total columnas de fecha a procesar: {len(columnas_existentes)}")

    # =========================
    # CONVERTIR COLUMNAS DE FECHA A DATETIME
    # =========================
    logger.info("\nüìÖ CONVIRTIENDO COLUMNAS DE FECHA A DATETIME...")
    
    for col in columnas_existentes:
        df = convertir_columna_fecha(df, col)

    # =========================
    # FILTRAR ESTATUS TRUE
    # =========================
    logger.info("\nüîç FILTRANDO POR ESTATUS = TRUE...")
    
    if "Estatus" in df.columns:
        filas_antes = len(df)
        df = df[df["Estatus"] == "True"].copy()
        filas_despues = len(df)
        logger.info(f"  Estatus='True' ‚Üí {filas_despues} filas (de {filas_antes})")
    else:
        logger.warning("‚ö†Ô∏è No se pudo encontrar columna 'Estatus'. Saltando filtro.")

    # =========================
    # LIMPIAR CIS / CIS_1
    # =========================
    logger.info("\nüßπ LIMPIANDO COLUMNAS CIS...")
    
    for col in ["CIS", "CIS_1"]:
        if col in df.columns:
            valores_antes = df[col].notna().sum()
            
            df[col] = (
                df[col]
                .astype(str)
                .str.replace(r"\D+", "", regex=True)
                .replace("nan", None)
                .replace("", None)
            )
            
            valores_despues = df[col].notna().sum()
            logger.info(f"  {col}: {valores_despues}/{valores_antes} valores despu√©s de limpiar")

    # =========================
    # CALCULAR TIEMPOS DE AGENTE Y ROBOT
    # =========================
    df = calcular_tiempos_agente_robot(df)

    # =========================
    # CALCULAR CATEGOR√çAS DE CARGOS
    # =========================
    df = calcular_categorias_cargos(df)

    # =========================
    # OTRAS TRANSFORMACIONES
    # =========================
    logger.info("\n‚öôÔ∏è APLICANDO OTRAS TRANSFORMACIONES...")
    
    # Convertir "Cargos" a n√∫mero (si no se hizo antes)
    if "Cargos" in df.columns and "Numero de cargos" not in df.columns:
        df["Numero de cargos"] = pd.to_numeric(
            df["Cargos"], errors="coerce"
        )
        logger.info(f"‚úì 'Cargos' convertido a n√∫mero para 'Numero de cargos'")
    
    # Si ya existe 'Numero de cargos' pero no tiene categor√≠as, calcularlas
    if "Numero de cargos" in df.columns and "Categoria de cargos" not in df.columns:
        df = calcular_categorias_cargos(df)
    
    # Cambiar Estatus a "Exitoso"
    if "Estatus" in df.columns:
        df["Estatus"] = "Exitoso"
        logger.info("‚úì 'Estatus' cambiado a 'Exitoso'")
    
    # Renombrar columna de nombre agente si existe
    posibles_nombres_agente = ["NOMBRE", "Nombre", "nombre", "Agente", "agente", "Nombre Agente"]
    for nombre in posibles_nombres_agente:
        if nombre in df.columns:
            if nombre != "Nombre Agente":  # Solo renombrar si no es ya el nombre correcto
                df = df.rename(columns={nombre: "Nombre Agente"})
                logger.info(f"‚úì {nombre} ‚Üí renombrada a 'Nombre Agente'")
            break
    
    if "Nombre Agente" not in df.columns:
        logger.warning("‚ö†Ô∏è No se encontr√≥ columna para 'Nombre Agente'")
        df["Nombre Agente"] = None

    # =========================
    # VERIFICAR COLUMNAS ANTES DE SELECCI√ìN
    # =========================
    logger.info("\nüîç VERIFICANDO COLUMNAS PARA SALIDA...")
    
    columnas_faltantes = []
    columnas_existentes = []
    
    for col in COLUMNAS_SALIDA:
        if col in df.columns:
            columnas_existentes.append(col)
        else:
            columnas_faltantes.append(col)
    
    logger.info(f"Columnas disponibles: {len(columnas_existentes)}/{len(COLUMNAS_SALIDA)}")
    
    if columnas_faltantes:
        logger.warning("Columnas faltantes:")
        for col in columnas_faltantes:
            logger.warning(f"  ‚ö†Ô∏è {col}")
        
        # Crear columnas faltantes vac√≠as
        for col in columnas_faltantes:
            df[col] = None
        logger.info("‚úì Columnas faltantes creadas como vac√≠as")

    # =========================
    # SELECCI√ìN FINAL Y ORDEN
    # =========================
    logger.info("\nüìã PREPARANDO DATAFRAME FINAL...")
    df_final = df[COLUMNAS_SALIDA].copy()
    
    # Ordenar por fecha si existe
    if "Fecha" in df_final.columns and df_final["Fecha"].notna().any():
        df_final = df_final.sort_values("Fecha", ascending=True)
        logger.info("‚úì Datos ordenados por 'Fecha'")
    
    logger.info(f"‚úì DataFrame final: {len(df_final)} filas √ó {len(df_final.columns)} columnas")

    # =========================
    # VERIFICAR RESULTADOS DE C√ÅLCULOS
    # =========================
    logger.info("\nüîç VERIFICANDO RESULTADOS DE C√ÅLCULOS Y CATEGOR√çAS...")
    
    # Verificar tiempos calculados
    if "Tiempo de captura agente" in df_final.columns:
        captura_calc = df_final["Tiempo de captura agente"].notna().sum()
        if captura_calc > 0:
            logger.info(f"‚úì Tiempo de captura agente: {captura_calc} calculados")
    
    if "Categoria tiempo agente" in df_final.columns:
        categorias_agente = df_final["Categoria tiempo agente"].value_counts()
        if not categorias_agente.empty:
            logger.info("Distribuci√≥n de categor√≠as tiempo agente:")
            for cat, count in categorias_agente.head(5).items():
                logger.info(f"  {cat}: {count}")
    
    if "Tiempo de alta robot" in df_final.columns:
        alta_calc = df_final["Tiempo de alta robot"].notna().sum()
        if alta_calc > 0:
            logger.info(f"‚úì Tiempo de alta robot: {alta_calc} calculados")
    
    if "Categoria tiempo Alta robot" in df_final.columns:
        categorias_robot = df_final["Categoria tiempo Alta robot"].value_counts()
        if not categorias_robot.empty:
            logger.info("Distribuci√≥n de categor√≠as tiempo alta robot:")
            for cat, count in categorias_robot.head(5).items():
                logger.info(f"  {cat}: {count}")
    
    if "Categoria de cargos" in df_final.columns:
        categorias_cargos = df_final["Categoria de cargos"].value_counts()
        if not categorias_cargos.empty:
            logger.info("Distribuci√≥n de categor√≠as de cargos:")
            for cat, count in categorias_cargos.head(5).items():
                logger.info(f"  {cat}: {count}")

    # =========================
    # EXPORTAR EXCEL
    # =========================
    logger.info(f"\nüì§ Exportando Excel: {OUTPUT_FILE}")
    
    with pd.ExcelWriter(
        OUTPUT_FILE,
        engine='openpyxl',
        date_format='yyyy-mm-dd hh:mm:ss',
        datetime_format='yyyy-mm-dd hh:mm:ss'
    ) as writer:
        df_final.to_excel(
            writer,
            index=False,
            sheet_name='Reporte'
        )
        
        # Ajustar ancho de columnas
        workbook = writer.book
        worksheet = writer.sheets['Reporte']
        
        for column in worksheet.columns:
            max_length = 0
            column_letter = column[0].column_letter
            
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            
            adjusted_width = min(max_length + 2, 50)
            worksheet.column_dimensions[column_letter].width = adjusted_width

    logger.info("‚úÖ Reporte Excel generado correctamente")
    logger.info(f"üìä Filas finales: {len(df_final)}")
    logger.info(f"üìÅ Ubicaci√≥n: {OUTPUT_FILE}")
    
    # Resumen final
    logger.info("\nüìã RESUMEN FINAL:")
    logger.info("="*60)
    logger.info(f"Archivo: {OUTPUT_FILE.name}")
    logger.info(f"Total filas: {len(df_final)}")
    
    # Resumen de categor√≠as
    if "Categoria tiempo agente" in df_final.columns:
        total_cat = df_final["Categoria tiempo agente"].notna().sum()
        logger.info(f"Categor√≠as tiempo agente calculadas: {total_cat}")
    
    if "Categoria tiempo Alta robot" in df_final.columns:
        total_cat = df_final["Categoria tiempo Alta robot"].notna().sum()
        logger.info(f"Categor√≠as tiempo alta robot calculadas: {total_cat}")
    
    if "Categoria de cargos" in df_final.columns:
        total_cat = df_final["Categoria de cargos"].notna().sum()
        logger.info(f"Categor√≠as de cargos calculadas: {total_cat}")
    
    logger.info("="*60)

# =========================
# EJECUCI√ìN
# =========================
if __name__ == "__main__":
    main()
