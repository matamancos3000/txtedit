import pandas as pd
import logging
from pathlib import Path
from datetime import datetime
import locale
import re

# =========================
# LOGGING
# =========================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# =========================
# CONFIGURACI√ìN
# =========================
BASE_PATH = Path("c:/Copia-reporte-Aclarabot")
EXCEL_PATH = BASE_PATH / "archivos_Excel"
EXCEL_PATH.mkdir(exist_ok=True)

CSV_FILE = next(BASE_PATH.glob("Acumulado_filtrado_*.csv"))

# Locale espa√±ol (solo para nombre del archivo)
try:
    locale.setlocale(locale.LC_TIME, "Spanish_Spain")
except:
    try:
        locale.setlocale(locale.LC_TIME, "es_ES")
    except:
        logger.warning("‚ö†Ô∏è Locale espa√±ol no disponible")

HOY = datetime.now()
FECHA_TEXTO = HOY.strftime("%d-%B").capitalize()
OUTPUT_FILE = EXCEL_PATH / f"Reporte_Aclarapp_{FECHA_TEXTO}.xlsx"

# =========================
# COLUMNAS DE SALIDA
# =========================
COLUMNAS_SALIDA = [
    "Fecha",
    "Tipo de tarjeta",
    "Tipo de aclaracion",
    "Detalles de aclaracion",
    "Cargos",
    "RobotID",
    "AclaracionID",
    "Estatus",
    "Registro",
    "Folio",
    "CIS",
    "Fecha Creacion",
    "Fecha Enviado",
    "Fecha Asignacion",
    "Fecha Atendido",
    "Tiempo de captura agente",
    "Tiempo de alta robot",
    "Tiempo de captura agente segundos",
    "Tiempo de alta robot segundos",
    "Numero de cargos",
    "Nombre Agente",
    "Supervisor",
    "Site",
    "Skill"
]

# =========================
# FUNCI√ìN PARA CONVERTIR FECHAS
# =========================
def convertir_columna_fecha(df, columna):
    """
    Convierte una columna de fecha de formato yyyy-MM-dd HH:mm:ss a datetime
    """
    if columna not in df.columns:
        logger.warning(f"‚ö†Ô∏è Columna '{columna}' no encontrada")
        return df
    
    logger.info(f"üîÑ Convirtiendo columna: {columna}")
    
    # Contar valores antes
    valores_antes = df[columna].notna().sum()
    logger.info(f"  Valores no nulos antes: {valores_antes}")
    
    if valores_antes == 0:
        logger.info("  ‚ö†Ô∏è No hay valores para convertir")
        return df
    
    # Mostrar algunos ejemplos del formato actual
    ejemplos = df[columna].dropna().head(3).tolist()
    logger.info("  Ejemplos del formato actual:")
    for i, ejemplo in enumerate(ejemplos):
        logger.info(f"    [{i}] '{ejemplo}'")
    
    try:
        # Intentar convertir del formato yyyy-MM-dd HH:mm:ss
        df[columna] = pd.to_datetime(
            df[columna],
            format='%Y-%m-%d %H:%M:%S',
            errors='coerce'
        )
        
        # Verificar conversi√≥n
        valores_despues = df[columna].notna().sum()
        logger.info(f"  Valores convertidos: {valores_despues}/{valores_antes}")
        
        if valores_despues < valores_antes:
            no_convertidos = valores_antes - valores_despues
            logger.warning(f"  ‚ö†Ô∏è {no_convertidos} valores no se pudieron convertir")
            
            # Mostrar algunos ejemplos de valores problem√°ticos
            problematicos = df[df[columna].isna() & df[columna].notna().shift()][columna].head(3)
            for idx, valor in problematicos.items():
                logger.warning(f"    No convertible: '{valor}'")
        
        # Mostrar ejemplos despu√©s de la conversi√≥n
        ejemplos_despues = df[columna].dropna().head(3).tolist()
        logger.info("  Ejemplos despu√©s de conversi√≥n:")
        for i, ejemplo in enumerate(ejemplos_despues):
            if isinstance(ejemplo, pd.Timestamp):
                logger.info(f"    [{i}] {ejemplo} (Timestamp)")
        
    except Exception as e:
        logger.error(f"‚ùå Error convirtiendo {columna}: {e}")
        
        # Intentar con otro m√©todo
        try:
            logger.info("  Intentando parseo autom√°tico...")
            df[columna] = pd.to_datetime(df[columna], errors='coerce')
            
            valores_despues = df[columna].notna().sum()
            logger.info(f"  Valores convertidos (autom√°tico): {valores_despues}/{valores_antes}")
        except Exception as e2:
            logger.error(f"  Error en parseo autom√°tico: {e2}")
    
    return df

# =========================
# MAIN
# =========================
def main():
    logger.info("üöÄ Generando Reporte Excel Aclarapp (CON conversi√≥n de fechas)")

    # =========================
    # CARGA CSV
    # =========================
    df = pd.read_csv(CSV_FILE, dtype=str, encoding="utf-8-sig")
    logger.info(f"‚úì CSV cargado: {CSV_FILE.name} ({len(df)} filas)")

    # =========================
    # VERIFICAR COLUMNAS DE FECHA EXISTENTES
    # =========================
    logger.info("\nüîç VERIFICANDO COLUMNAS DE FECHA...")
    
    columnas_fecha = [
        "Fecha",
        "Fecha Creacion",  # Nota: en el CSV original es "Fecha Creaci√≥n" con acento
        "Fecha Enviado",
        "Fecha Asignacion",
        "Fecha Atendido"
    ]
    
    # Verificar qu√© columnas realmente existen
    columnas_existentes = []
    for col in columnas_fecha:
        if col in df.columns:
            columnas_existentes.append(col)
            logger.info(f"  ‚úì {col}: encontrada")
        else:
            # Buscar variantes (con acentos, etc.)
            posibles_variantes = [
                "Fecha Creaci√≥n",  # Con acento
                "Fecha Creaci√≥n",  # Original
                "Fecha_Creacion",  # Con gui√≥n bajo
                "Fecha Creacion"   # Sin acento
            ]
            
            encontrada = False
            for variante in posibles_variantes:
                if variante in df.columns:
                    # Renombrar para uniformidad
                    df = df.rename(columns={variante: col})
                    columnas_existentes.append(col)
                    logger.info(f"  ‚úì {variante} ‚Üí renombrada a {col}")
                    encontrada = True
                    break
            
            if not encontrada:
                logger.warning(f"  ‚ö†Ô∏è {col}: NO encontrada")
    
    logger.info(f"Total columnas de fecha a procesar: {len(columnas_existentes)}")

    # =========================
    # CONVERTIR COLUMNAS DE FECHA
    # =========================
    logger.info("\nüìÖ CONVIRTIENDO COLUMNAS DE FECHA A DATETIME...")
    logger.info("Formato origen: yyyy-MM-dd HH:mm:ss")
    logger.info("Formato destino: datetime (para Excel)")
    
    for col in columnas_existentes:
        df = convertir_columna_fecha(df, col)

    # =========================
    # FILTRAR ESTATUS TRUE
    # =========================
    logger.info("\nüîç FILTRANDO POR ESTATUS = TRUE...")
    
    # Verificar columna de estatus
    if "Estatus" not in df.columns:
        logger.warning("‚ö†Ô∏è Columna 'Estatus' no encontrada. Buscando variantes...")
        posibles_estatus = ["Estatus", "estatus", "ESTATUS", "Status", "status"]
        for variante in posibles_estatus:
            if variante in df.columns:
                df = df.rename(columns={variante: "Estatus"})
                logger.info(f"  ‚úì {variante} ‚Üí renombrada a 'Estatus'")
                break
    
    if "Estatus" in df.columns:
        filas_antes = len(df)
        df = df[df["Estatus"] == "True"].copy()
        filas_despues = len(df)
        logger.info(f"  Estatus='True' ‚Üí {filas_despues} filas (de {filas_antes})")
    else:
        logger.warning("‚ö†Ô∏è No se pudo encontrar columna 'Estatus'. Saltando filtro.")

    # =========================
    # LIMPIAR CIS / CIS_1
    # =========================
    logger.info("\nüßπ LIMPIANDO COLUMNAS CIS...")
    
    for col in ["CIS", "CIS_1"]:
        if col in df.columns:
            valores_antes = df[col].notna().sum()
            
            df[col] = (
                df[col]
                .astype(str)
                .str.replace(r"\D+", "", regex=True)
                .replace("nan", None)
                .replace("", None)
            )
            
            valores_despues = df[col].notna().sum()
            logger.info(f"  {col}: {valores_despues}/{valores_antes} valores despu√©s de limpiar")
        else:
            logger.info(f"  ‚ö†Ô∏è {col}: no encontrada")

    # =========================
    # CAMPOS DE TIEMPO VAC√çOS (A√öN)
    # =========================
    df["Tiempo de captura agente"] = None
    df["Tiempo de alta robot"] = None
    df["Tiempo de captura agente segundos"] = None
    df["Tiempo de alta robot segundos"] = None
    logger.info("‚úì Campos de tiempo inicializados como vac√≠os")

    # =========================
    # OTRAS TRANSFORMACIONES
    # =========================
    logger.info("\n‚öôÔ∏è APLICANDO OTRAS TRANSFORMACIONES...")
    
    # Convertir "Cargos" a n√∫mero
    if "Cargos" in df.columns:
        df["Numero de cargos"] = pd.to_numeric(
            df["Cargos"], errors="coerce"
        )
        logger.info(f"‚úì 'Cargos' convertido a n√∫mero para 'Numero de cargos'")
    else:
        logger.warning("‚ö†Ô∏è Columna 'Cargos' no encontrada")
        df["Numero de cargos"] = None
    
    # Cambiar Estatus a "Exitoso"
    if "Estatus" in df.columns:
        df["Estatus"] = "Exitoso"
        logger.info("‚úì 'Estatus' cambiado a 'Exitoso'")
    
    # Renombrar columna de nombre agente si existe
    posibles_nombres_agente = ["NOMBRE", "Nombre", "nombre", "Agente", "agente"]
    for nombre in posibles_nombres_agente:
        if nombre in df.columns:
            df = df.rename(columns={nombre: "Nombre Agente"})
            logger.info(f"‚úì {nombre} ‚Üí renombrada a 'Nombre Agente'")
            break
    
    if "Nombre Agente" not in df.columns:
        logger.warning("‚ö†Ô∏è No se encontr√≥ columna para 'Nombre Agente'")
        df["Nombre Agente"] = None

    # =========================
    # VERIFICAR COLUMNAS ANTES DE SELECCI√ìN
    # =========================
    logger.info("\nüîç VERIFICANDO COLUMNAS PARA SALIDA...")
    
    columnas_faltantes = []
    columnas_existentes = []
    
    for col in COLUMNAS_SALIDA:
        if col in df.columns:
            columnas_existentes.append(col)
        else:
            columnas_faltantes.append(col)
    
    logger.info(f"Columnas disponibles: {len(columnas_existentes)}/{len(COLUMNAS_SALIDA)}")
    
    if columnas_faltantes:
        logger.warning("Columnas faltantes:")
        for col in columnas_faltantes:
            logger.warning(f"  ‚ö†Ô∏è {col}")
        
        # Crear columnas faltantes vac√≠as
        for col in columnas_faltantes:
            df[col] = None
        logger.info("‚úì Columnas faltantes creadas como vac√≠as")

    # =========================
    # SELECCI√ìN FINAL
    # =========================
    logger.info("\nüìã PREPARANDO DATAFRAME FINAL...")
    df_final = df[COLUMNAS_SALIDA].copy()
    logger.info(f"‚úì DataFrame final: {len(df_final)} filas √ó {len(df_final.columns)} columnas")

    # =========================
    # VERIFICAR FORMATO DE FECHAS ANTES DE EXPORTAR
    # =========================
    logger.info("\nüîç VERIFICANDO FORMATO DE FECHAS FINALES...")
    
    columnas_fecha_final = ["Fecha", "Fecha Creacion", "Fecha Enviado", "Fecha Asignacion", "Fecha Atendido"]
    
    for col in columnas_fecha_final:
        if col in df_final.columns:
            tipo = df_final[col].dtype
            no_nulos = df_final[col].notna().sum()
            
            if pd.api.types.is_datetime64_any_dtype(tipo):
                logger.info(f"  {col:<20}: {no_nulos:>5} valores | Tipo: datetime ‚úì")
                
                # Mostrar rango de fechas
                if no_nulos > 0:
                    fecha_min = df_final[col].min()
                    fecha_max = df_final[col].max()
                    logger.info(f"      Rango: {fecha_min} a {fecha_max}")
            else:
                logger.warning(f"  {col:<20}: {no_nulos:>5} valores | Tipo: {tipo} ‚úó")

    # =========================
    # EXPORTAR EXCEL CON FORMATO DE FECHAS
    # =========================
    logger.info(f"\nüì§ Exportando Excel: {OUTPUT_FILE}")
    
    # Crear un escritor de Excel
    with pd.ExcelWriter(
        OUTPUT_FILE,
        engine='openpyxl',
        date_format='yyyy-mm-dd hh:mm:ss',
        datetime_format='yyyy-mm-dd hh:mm:ss'
    ) as writer:
        df_final.to_excel(
            writer,
            index=False,
            sheet_name='Reporte'
        )
        
        # Acceder al libro y hoja para ajustes adicionales
        workbook = writer.book
        worksheet = writer.sheets['Reporte']
        
        # Ajustar ancho de columnas autom√°ticamente
        for column in worksheet.columns:
            max_length = 0
            column_letter = column[0].column_letter  # Get the column name
            
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            
            adjusted_width = min(max_length + 2, 50)  # Limitar a 50 caracteres m√°ximo
            worksheet.column_dimensions[column_letter].width = adjusted_width

    logger.info("‚úÖ Reporte Excel generado correctamente")
    logger.info(f"üìä Filas finales: {len(df_final)}")
    logger.info(f"üìÅ Ubicaci√≥n: {OUTPUT_FILE}")
    
    # Resumen final
    logger.info("\nüìã RESUMEN FINAL:")
    logger.info("="*60)
    
    # Informaci√≥n de fechas
    columnas_fecha_resumen = ["Fecha", "Fecha Creacion", "Fecha Enviado", "Fecha Asignacion", "Fecha Atendido"]
    logger.info("COLUMNAS DE FECHA (formato datetime para Excel):")
    
    for col in columnas_fecha_resumen:
        if col in df_final.columns:
            no_nulos = df_final[col].notna().sum()
            if no_nulos > 0:
                ejemplo = df_final[col].iloc[0]
                if pd.notna(ejemplo):
                    logger.info(f"  {col:<20}: {no_nulos:>5} valores | Ej: {ejemplo}")
    
    logger.info("="*60)

# =========================
# EJECUCI√ìN
# =========================
if __name__ == "__main__":
    main()
